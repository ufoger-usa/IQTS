<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>IQTS AI Trading Dashboard</title>
    <style>
        /* Mobile optimization CSS */
        @media (max-width: 768px) {
            .stats {
                grid-template-columns: 1fr;
            }
            .watchlist-item {
                flex-direction: column;
            }
            .grid-container {
                grid-template-columns: 1fr;
            }
            .stats-grid {
                grid-template-columns: 1fr 1fr;
            }
            .watchlist-item {
                flex-direction: row;
                flex-wrap: wrap;
            }
            .modal {
                width: 90%;
                max-width: none;
            }
        }
        :root {
            --primary: #ffffff; /* White for primary actions */
            --positive: #ffffff; /* White for positive values */
            --negative: #cccccc; /* Light gray for negative values */
            --neutral: #888888; /* Medium gray for neutral elements */
            --bg: #000000; /* Pure black background */
            --panel-bg: #111111; /* Slightly lighter black for panels */
            --text: #ffffff; /* White text */
            --border: #333333; /* Dark gray borders */
            --header-bg: #000000; /* Black header */
            --tab-bg: #222222; /* Dark gray tabs */
            --watchlist-bg: #1a1a1a; /* Slightly lighter than panel */
            --signal-bg: #151515; /* Dark background for signals */
            --auto-buy: rgba(255, 255, 255, 0.1); /* White with low opacity */
            --auto-sell: rgba(204, 204, 204, 0.1); /* Light gray with low opacity */
            --high-confidence: #ffffff; /* White */
            --medium-confidence: #aaaaaa; /* Light gray */
            --low-confidence: #666666; /* Dark gray */
        }

        .dark-mode {
            --primary: #ffffff; /* Keep white for primary actions */
            --positive: #ffffff; /* White for positive values */
            --negative: #cccccc; /* Light gray for negative values */
            --neutral: #888888; /* Medium gray for neutral elements */
            --bg: #000000; /* Pure black background */
            --panel-bg: #111111; /* Slightly lighter black for panels */
            --text: #ffffff; /* White text */
            --border: #333333; /* Dark gray borders */
            --header-bg: #000000; /* Black header */
            --tab-bg: #222222; /* Dark gray tabs */
            --watchlist-bg: #1a1a1a; /* Slightly lighter than panel */
            --signal-bg: #151515; /* Dark background for signals */
            --auto-buy: rgba(255, 255, 255, 0.1); /* White with low opacity */
            --auto-sell: rgba(204, 204, 204, 0.1); /* Light gray with low opacity */
            --high-confidence: #ffffff; /* White */
            --medium-confidence: #aaaaaa; /* Light gray */
            --low-confidence: #666666; /* Dark gray */
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 15px;
            background-color: var(--bg);
            color: var(--text);
            transition: background-color 0.3s, color 0.3s;
            -webkit-tap-highlight-color: transparent;
        }

        h1, h2, h3, h4 {
            color: var(--text);
            margin-top: 0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
        }

        .panel {
            background-color: var(--panel-bg);
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 15px;
            margin-bottom: 15px;
            transition: background-color 0.3s;
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            min-width: 600px;
        }

        th, td {
            padding: 12px 8px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        th {
            background-color: var(--tab-bg);
            font-weight: 600;
            position: sticky;
            top: 0;
        }

        tr:hover {
            background-color: var(--tab-bg);
        }

        .positive {
            color: var(--positive);
            font-weight: bold;
        }

        .negative {
            color: var(--negative);
            font-weight: bold;
        }

        .neutral {
            color: var(--neutral);
        }

        button, input[type="submit"] {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s;
            min-width: 44px;
            min-height: 44px;
        }

        button:hover, input[type="submit"]:hover {
            background-color: #2980b9;
        }

        .buy-btn {
            background-color: var(--positive);
        }

        .sell-btn {
            background-color: var(--negative);
        }

        input, select, textarea {
            padding: 12px;
            border: 1px solid var(--border);
            border-radius: 6px;
            width: 100%;
            box-sizing: border-box;
            margin-bottom: 12px;
            background-color: var(--panel-bg);
            color: var(--text);
            font-size: 16px;
            min-height: 44px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 16px;
        }

        .chart-link {
            color: var(--primary);
            text-decoration: none;
            padding: 5px;
            display: inline-block;
        }

        .chart-link:hover {
            text-decoration: underline;
        }

        .stats-container {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            width: 49%;
        }

        .stat-box {
            background-color: var(--panel-bg);
            padding: 8px;
            border-radius: 6px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            text-align: center;
        }

        .stat-value {
            font-size: 15px;
            font-weight: bold;
            margin: 3px 0;
        }
        
        .stat-label {
            font-size: 12px;
        }
        
        .alpaca-stats .stat-value {
            color: var(--primary);
        }

        .stat-label {
            font-size: 12px;
            color: var(--neutral);
        }

        #watchlist-items {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }

        .watchlist-item {
            background-color: var(--watchlist-bg);
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 16px;
            display: flex;
            align-items: center;
            min-height: 44px;
        }

        .watchlist-item button {
            background-color: transparent;
            color: var(--neutral);
            padding: 0;
            margin-left: 8px;
            font-size: 16px;
            min-width: 30px;
            min-height: 30px;
        }

        .watchlist-item button:hover {
            color: var(--negative);
        }

        .tabs {
            display: flex;
            margin-bottom: 15px;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .tab {
            padding: 12px 20px;
            cursor: pointer;
            background-color: var(--tab-bg);
            border-radius: 5px 5px 0 0;
            margin-right: 5px;
            white-space: nowrap;
            min-width: 80px;
            text-align: center;
            font-size: 16px;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tab.active {
            background-color: var(--primary);
            color: white;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .quick-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .quick-action-btn {
            padding: 10px 15px;
            font-size: 16px;
            min-width: 44px;
            min-height: 44px;
        }

        #tradingview-chart {
            height: 600px; /* Double the height */
            width: 100%;
            margin-top: 20px;
            border-radius: 8px;
            overflow: hidden;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .ai-monitor {
            margin-top: 20px;
            border-top: 1px solid var(--border);
            padding-top: 20px;
        }

        .ai-signal {
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 15px;
            background-color: var(--signal-bg);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .signal-buy {
            border-left: 4px solid var(--positive);
        }

        .signal-sell {
            border-left: 4px solid var(--negative);
        }

        .signal-info {
            flex: 1;
            min-width: 200px;
        }

        .signal-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .alpaca-connected {
            background-color: var(--positive);
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 14px;
            margin-left: 10px;
        }

        .alpaca-disconnected {
            background-color: var(--negative);
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 14px;
            margin-left: 10px;
        }

        .alpaca-paper {
            background-color: #f39c12;
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 14px;
            margin-left: 10px;
        }

        .market-status {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            padding: 15px;
            border-radius: 5px;
            background-color: var(--signal-bg);
            flex-wrap: wrap;
            gap: 10px;
        }

        .market-status-indicator {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .market-open {
            background-color: var(--positive);
        }

        .market-closed {
            background-color: var(--negative);
        }

        .market-prepost {
            background-color: #f39c12;
        }

        .market-status-info {
            flex: 1;
            min-width: 200px;
        }

        .market-status-timer {
            font-weight: bold;
            margin-left: 10px;
            font-size: 16px;
        }

        .market-hours {
            font-size: 14px;
            color: var(--neutral);
            margin-top: 5px;
        }

        .strategy-switcher {
            margin-bottom: 15px;
            padding: 15px;
            background-color: var(--watchlist-bg);
            border-radius: 5px;
        }

        .strategy-switcher h3 {
            margin: 0;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        #strategy-selector {
            border: 1px solid var(--border);
            border-radius: 4px;
            background-color: var(--panel-bg);
            color: var(--text);
            padding: 10px;
            font-size: 16px;
            min-height: 44px;
        }

        .header-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .mode-toggle {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .toggle-btn {
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            min-width: 44px;
            min-height: 44px;
        }

        .dark-toggle {
            background-color: #333;
            color: white;
        }

        .light-toggle {
            background-color: #eee;
            color: #333;
        }

        .active-mode {
            font-weight: bold;
            box-shadow: 0 0 0 2px var(--primary);
        }

        .portfolio-summary {
            margin-top: 20px;
            padding: 15px;
            background-color: var(--signal-bg);
            border-radius: 8px;
        }

        .portfolio-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid var(--border);
        }

        .portfolio-item:last-child {
            border-bottom: none;
        }

        .portfolio-value {
            font-weight: bold;
            font-size: 14px;
        }

        .portfolio-label {
            font-size: 14px;
        }

        /* Signals Grid Layout */
        .signals-container {
          display: grid;
          grid-template-columns: repeat(3, 1fr);
          grid-template-rows: auto auto;
          gap: 10px;
          margin-bottom: 15px;
        }

        /* Signal Cards */
        .signal-card {
          background-color: var(--panel-bg);
          border-radius: 8px;
          padding: 12px;
          border-left: 4px solid var(--positive);
          display: flex;
          flex-direction: column;
          min-height: 120px;
        }

        .signal-card.sell {
          border-left-color: var(--negative);
        }

        .signal-title {
          font-weight: bold;
          margin-bottom: 6px;
          display: flex;
          justify-content: space-between;
          font-size: 14px;
        }

        .signal-price {
          font-size: 16px;
          font-weight: bold;
          margin: 5px 0;
          text-align: center;
        }

        .signal-profit {
          font-size: 14px;
          font-weight: bold;
          text-align: center;
          margin: 5px 0;
          padding: 4px;
          border-radius: 4px;
        }

        .profit-positive {
          background-color: rgba(39, 174, 96, 0.2);
          color: var(--positive);
        }

        .profit-negative {
          background-color: rgba(231, 76, 60, 0.2);
          color: var(--negative);
        }

        .signal-meta {
          font-size: 12px;
          color: var(--neutral);
          margin-bottom: 6px;
        }

        .signal-actions {
          display: flex;
          gap: 6px;
          margin-top: auto;
        }

        /* Strategy Info Toggle */
        .strategy-info-toggle {
            background-color: var(--panel-bg);
            padding: 12px 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s;
            border-left: 4px solid var(--primary);
        }

        .strategy-info-toggle:hover {
            background-color: var(--tab-bg);
        }

        .strategy-info-toggle span:last-child {
            transition: transform 0.3s ease;
        }

        .strategy-info-toggle.collapsed span:last-child {
            transform: rotate(-90deg);
        }

        .strategy-info-content {
            background-color: var(--panel-bg);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            max-height: 300px;
            overflow: hidden;
            transition: max-height 0.5s ease, opacity 0.3s ease, margin-bottom 0.5s ease, padding 0.5s ease;
        }

        .strategy-info-content.collapsed {
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
            margin-bottom: 5px;
            opacity: 0;
            overflow: hidden;
        }

        /* Fullscreen chart with signals */
        .fullscreen-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg);
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }

        .fullscreen-chart {
            flex: 1;
            height: calc(100% - 300px);
        }

        .fullscreen-signals {
            height: 300px;
            padding: 15px;
            overflow-y: auto;
            background: var(--panel-bg);
        }

        /* New automation styles */
        .automation-controls {
            background-color: var(--panel-bg);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            border-left: 4px solid var(--primary);
            position: relative;
            overflow: hidden;
        }

        .automation-controls h3 {
            display: flex;
            align-items: center;
            position: relative;
        }

        .automation-controls h3::before {
            content: '';
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-right: 10px;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%233498db"><path d="M12 2c-5.52 0-10 4.48-10 10s4.48 10 10 10 10-4.48 10-10-4.48-10-10-10zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-12h2v6h-2z"/><path d="M10 18h4v2h-4z"/></svg>') center/contain no-repeat;
            transition: transform 0.5s ease;
        }

        .auto-trading-active .automation-controls h3::before {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* Radar animation */
        .radar-container {
            position: absolute;
            top: 0;
            right: 0;
            width: 60px;
            height: 60px;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .auto-trading-active .radar-container {
            opacity: 0.3;
        }

        .radar-circle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid var(--primary);
        }

        .radar-beam {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 1px;
            height: 20px;
            background-color: var(--primary);
            transform-origin: bottom center;
            animation: radar-sweep 2s infinite linear;
        }

        @keyframes radar-sweep {
            from { transform: translateX(-50%) translateY(-100%) rotate(0deg); }
            to { transform: translateX(-50%) translateY(-100%) rotate(360deg); }
        }

        .toggle-group {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .toggle-group label {
            display: flex;
            align-items: center;
            cursor: pointer;
            margin-right: 15px;
        }

        .safety-settings {
            background-color: var(--signal-bg);
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
        }

        .confidence-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .high-confidence {
            background-color: var(--high-confidence);
        }

        .medium-confidence {
            background-color: var(--medium-confidence);
        }

        .low-confidence {
            background-color: var(--low-confidence);
        }

        .auto-trade-row {
            background-color: var(--auto-buy);
        }

        .auto-trade-row.sell {
            background-color: var(--auto-sell);
        }

        .indicator-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .trade-history-btn {
            background-color: var(--neutral);
            margin-left: auto;
        }

        /* Toast notifications */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
        }

        .toast {
            padding: 12px 15px;
            border-radius: 6px;
            margin-bottom: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: space-between;
            min-width: 250px;
            max-width: 350px;
            animation: slideIn 0.3s, fadeOut 0.5s 5s forwards;
        }

        .toast-success {
            background-color: var(--positive);
            color: white;
        }

        .toast-warning {
            background-color: #f39c12;
            color: white;
        }

        .toast-error {
            background-color: var(--negative);
            color: white;
        }

        .toast-close {
            background: none;
            border: none;
            color: white;
            font-weight: bold;
            cursor: pointer;
            padding: 0;
            min-width: unset;
            min-height: unset;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); }
            to { transform: translateX(0); }
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        /* Modal styles */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9990;
        }

        .modal-wrapper {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6);
            display: none;
            z-index: 10000; /* Make sure it's on top of everything */
        }

        .modal-content {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--panel-bg);
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            z-index: 10001;
        }

        .modal-header {
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border);
        }

        .modal-body {
            padding: 15px;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            min-width: unset;
            min-height: unset;
            color: var(--text);
        }

        /* Responsive adjustments */
        @media (max-width: 1200px) {
            .stats {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (max-width: 768px) {
            .stats {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .signals-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 480px) {
            .stats {
                grid-template-columns: 1fr;
            }
            
            .header-controls {
                flex-direction: column;
                align-items: flex-start;
            }
        }

        /* Touch optimizations */
        button, input[type="submit"], .tab, .watchlist-item {
            -webkit-tap-highlight-color: transparent;
        }

        input[type="number"] {
            -webkit-appearance: none;
            -moz-appearance: textfield;
            appearance: none;
        }

        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            appearance: none;
            margin: 0;
        }

        /* Alpaca API Modal */
        .modal-wrapper {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }

        .modal-wrapper .modal-content {
            background-color: var(--panel-bg);
            margin: 15% auto;
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .close-modal {
            color: var(--neutral);
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close-modal:hover {
            color: var(--text);
        }

        .modal-tabs {
            display: flex;
            margin-bottom: 15px;
        }

        .modal-tab {
            padding: 10px 20px;
            cursor: pointer;
            background-color: var(--tab-bg);
            border-radius: 5px 5px 0 0;
            margin-right: 5px;
        }

        .modal-tab.active {
            background-color: var(--primary);
            color: white;
        }

        .modal-tab-content {
            display: none;
        }

        .modal-tab-content.active {
            display: block;
        }

        /* New automation styles */
        .automation-controls {
            margin-bottom: 15px;
            border-left: 4px solid var(--primary);
        }

        .automation-controls h3 {
            margin-top: 0;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }

        .automation-controls h3::before {
            content: '🤖';
            margin-right: 8px;
            font-size: 1.2em;
        }

        .toggle-group {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .toggle-group label {
            display: flex;
            align-items: center;
            cursor: pointer;
            margin-right: 15px;
        }

        .toggle-group input[type="checkbox"] {
            margin-right: 5px;
        }

        #auto-trading-status {
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .safety-settings {
            background-color: var(--bg);
            padding: 12px;
            border-radius: 6px;
            margin-top: 10px;
            border: 1px solid var(--border);
        }

        .safety-settings h4 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1em;
        }

        .safety-settings .form-group {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .safety-settings .form-group label {
            flex: 1;
            margin-right: 10px;
            color: var(--text);
            font-size: 0.9em;
        }

        .safety-settings input,
        .safety-settings select {
            width: 120px;
            padding: 6px;
            border: 1px solid var(--border);
            border-radius: 4px;
            background-color: var(--panel-bg);
            color: var(--text);
        }

        #auto-trade-stats {
            font-size: 0.9em;
            color: var(--text);
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        #auto-trade-stats p {
            margin: 0;
        }

        .confidence-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .high-confidence {
            background-color: var(--positive);
        }

        .medium-confidence {
            background-color: #f39c12;
        }

        .low-confidence {
            background-color: var(--negative);
        }

        .auto-buy-signal {
            background-color: rgba(39, 174, 96, 0.1);
            border-left: 4px solid var(--positive);
        }

        .auto-sell-signal {
            background-color: rgba(231, 76, 60, 0.1);
            border-left: 4px solid var(--negative);
        }

        .signal-quality {
            font-size: 12px;
            margin-top: 5px;
            display: flex;
            align-items: center;
        }

        .auto-trade-badge {
            background-color: var(--primary);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            margin-left: 5px;
        }

        /* Trade notification styles */
        .trade-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 300px;
            background-color: var(--panel-bg);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            overflow: hidden;
            animation: slide-in 0.3s ease-out;
        }

        .trade-notification.buy {
            border-left: 4px solid var(--positive);
        }

        .trade-notification.sell {
            border-left: 4px solid var(--negative);
        }

        .notification-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.05);
            border-bottom: 1px solid var(--border);
        }

        .notification-body {
            padding: 10px;
        }

        .close-notification {
            cursor: pointer;
            font-size: 18px;
            color: var(--text);
            opacity: 0.7;
        }

        .close-notification:hover {
            opacity: 1;
        }

        @keyframes slide-in {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Trade History Modal */
        .trade-history-table {
            width: 100%;
            overflow-x: auto;
        }

        .trade-history-header, .trade-history-row {
            display: grid;
            grid-template-columns: 1.5fr 1fr 0.8fr 1fr 1fr 1fr;
            padding: 8px 0;
        }

        .trade-history-header {
            font-weight: bold;
            border-bottom: 1px solid var(--border);
        }

        .trade-history-row {
            border-bottom: 1px solid var(--border);
        }

        .trade-history-row .buy {
            color: var(--positive);
        }

        .trade-history-row .sell {
            color: var(--negative);
        }

        .trade-history-row .profit {
            color: var(--positive);
        }

        .trade-history-row .loss {
            color: var(--negative);
        }

        /* Responsive styles for automation features */
        @media (max-width: 768px) {
            .safety-settings .form-group {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .safety-settings .form-group label {
                margin-bottom: 5px;
            }
            
            .safety-settings input,
            .safety-settings select {
                width: 100%;
            }
            
            #auto-trade-stats {
                grid-template-columns: 1fr;
            }
        }

    /* Enhanced Auto-Trading Panel */
    .automation-header {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 15px;
    }
    
    .automation-status {
        display: flex;
        align-items: center;
        gap: 5px;
        font-weight: bold;
    }
    
    .status-indicator {
        width: 12px;
        height: 12px;
        border-radius: 50%;
    }
    
    .status-active {
        background-color: var(--positive);
        box-shadow: 0 0 8px var(--positive);
        animation: pulse 1.5s infinite;
    }
    
    .status-paused {
        background-color: var(--medium-confidence);
        box-shadow: 0 0 8px var(--medium-confidence);
    }
    
    .status-disabled {
        background-color: var(--negative);
    }
    
    /* Telegram status styles */
    .telegram-status {
        margin-top: 15px;
        padding: 15px;
        background-color: #2d2d2d;
        border-radius: 8px;
        display: flex;
        flex-direction: column;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
    
    .telegram-status-header {
        display: flex;
        align-items: center;
        margin-bottom: 8px;
        width: 100%;
    }
    
    .telegram-status-icon {
        width: 24px;
        height: 24px;
        margin-right: 10px;
        background-color: #0088cc;
        mask: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.78 18.65l.28-4.23 7.68-6.92c.34-.31-.07-.46-.52-.19L7.74 13.3 3.64 12c-.88-.25-.89-.86.2-1.3l15.97-6.16c.73-.33 1.43.18 1.15 1.3l-2.72 12.81c-.19.91-.74 1.13-1.5.71L12.6 16.3l-1.99 1.93c-.23.23-.42.42-.83.42z"></path></svg>') center/contain no-repeat;
        -webkit-mask: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.78 18.65l.28-4.23 7.68-6.92c.34-.31-.07-.46-.52-.19L7.74 13.3 3.64 12c-.88-.25-.89-.86.2-1.3l15.97-6.16c.73-.33 1.43.18 1.15 1.3l-2.72 12.81c-.19.91-.74 1.13-1.5.71L12.6 16.3l-1.99 1.93c-.23.23-.42.42-.83.42z"></path></svg>') center/contain no-repeat;
    }
    
    .telegram-commands {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        width: 100%;
        margin-top: 10px;
    }
    
    .telegram-command {
        background-color: white;
        color: #333;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 8px 15px;
        font-family: monospace;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s ease;
        min-width: auto;
        min-height: auto;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .telegram-command:hover {
        background-color: #f0f0f0;
        border-color: #ccc;
    }
    
    /* Slider feedback animation */
    .slider-feedback {
        font-size: 12px;
        color: var(--positive);
        margin-top: 3px;
        opacity: 0;
        transition: opacity 0.3s ease;
    }
    
    /* Performance Dashboard Styles */
    #performance-dashboard {
        margin-top: 20px;
        background-color: var(--panel-bg);
    }
    
    .metrics {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 15px;
        margin: 15px 0;
    }
    
    @media (min-width: 768px) {
        .metrics {
            grid-template-columns: repeat(4, 1fr);
        }
    }
    
    .metric {
        display: flex;
        flex-direction: column;
        align-items: center;
        background-color: var(--tab-bg);
        padding: 15px;
        border-radius: 6px;
        text-align: center;
    }
    
    .metric .value {
        font-size: 24px;
        font-weight: bold;
        margin-bottom: 5px;
        color: var(--primary);
    }
    
    .metric .label {
        font-size: 14px;
        color: var(--neutral);
    }
    
    #refresh-stats {
        padding: 8px 15px;
        background-color: var(--primary);
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        min-height: 36px;
        min-width: 36px;
    }
    
    #refresh-stats:hover {
        background-color: #2980b9;
    }
    
    /* Slider style improvements */
    input[type=range] {
        -webkit-appearance: none;
        appearance: none;
        margin: 10px 0;
        width: 100%;
        background: transparent;
    }
    
    input[type=range]:focus {
        outline: none;
    }
    
    input[type=range]::-webkit-slider-runnable-track {
        width: 100%;
        height: 5px;
        cursor: pointer;
        background: var(--primary);
        border-radius: 3px;
    }
    
    input[type=range]::-webkit-slider-thumb {
        border: 1px solid var(--border);
        height: 18px;
        width: 18px;
        border-radius: 50%;
        background: #ffffff;
        cursor: pointer;
        -webkit-appearance: none;
        margin-top: -7px;
        box-shadow: 0px 1px 3px rgba(0,0,0,0.2);
    }
    
    /* Radar Animation */
    .radar-visualization {
        position: relative;
        width: 100px;
        height: 100px;
        margin: 10px auto;
    }
    
    .radar-scan {
        position: absolute;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        border: 2px solid rgba(52, 152, 219, 0.3);
    }
    
    .radar-scan::after {
        content: '';
        position: absolute;
        top: 0;
        left: 50%;
        width: 2px;
        height: 50%;
        background: linear-gradient(to bottom, transparent, var(--primary));
        transform-origin: bottom center;
        animation: radar-sweep 3s linear infinite;
    }
    
    /* Auto-Trading Stats Grid */
    .auto-stats-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
        margin-top: 15px;
    }
    
    .auto-stat-card {
        background: var(--panel-bg);
        border-radius: 8px;
        padding: 10px;
        text-align: center;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    
    .auto-stat-value {
        font-size: 18px;
        font-weight: bold;
        margin: 5px 0;
    }
    
    /* Animations */
    @keyframes pulse {
        0% { opacity: 1; }
        50% { opacity: 0.5; }
        100% { opacity: 1; }
    }
    
    @keyframes radar-sweep {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }

    /* Additional style adjustments for monochrome black scheme */
    button, input[type="submit"] {
        color: #000000; /* Black text on buttons */
        border: 1px solid var(--border);
    }

    .buy-btn {
        background-color: var(--text); /* White background */
        color: #000000 !important; /* Black text */
    }

    .sell-btn {
        background-color: var(--neutral); /* Gray background */
        color: #000000 !important; /* Black text */
    }

    .tab.active {
        color: #000000; /* Black text for active tabs */
    }

    .market-open {
        background-color: var(--text); /* White for open market */
    }

    .market-closed {
        background-color: var(--neutral); /* Gray for closed market */
    }

    .market-prepost {
        background-color: var(--medium-confidence); /* Light gray for pre/post market */
    }

    /* Adjust chart colors */
    #tradingview-chart, .tradingview-widget-container, canvas {
        filter: grayscale(100%) contrast(120%);
    }

    /* Table row hover effect */
    tr:hover {
        background-color: #222222 !important;
    }

    /* Modal styling */
    .modal-content {
        border: 1px solid var(--border);
    }

    /* Input fields */
    input, select, textarea {
        border: 1px solid var(--border);
        color: var(--text);
    }

    /* Disabled elements */
    button:disabled {
        background-color: #333333 !important;
        color: #666666 !important;
    }
    </style>
    <!-- TradingView Widget -->
    <script type="text/javascript" src="https://s3.tradingview.com/tv.js"></script>
    <!-- Moment.js for time handling -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment-timezone/0.5.33/moment-timezone-with-data.min.js"></script>
    <!-- Chart.js for equity curve -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <!-- Custom Alpaca API Client -->
    <script>
        // Create a simple Alpaca API client
        class AlpacaClient {
            constructor(options) {
                this.keyId = options.keyId;
                this.secretKey = options.secretKey;
                this.baseUrl = options.baseUrl || 'https://api.alpaca.markets';
                this.apiVersion = options.apiVersion || 'v2';
                this.paper = options.paper || false;
            }

            async makeRequest(endpoint, method = 'GET', data = null) {
                const url = `${this.baseUrl}/${this.apiVersion}/${endpoint}`;
                
                const headers = {
                    'APCA-API-KEY-ID': this.keyId,
                    'APCA-API-SECRET-KEY': this.secretKey,
                    'Content-Type': 'application/json'
                };
                
                const options = {
                    method: method,
                    headers: headers
                };
                
                if (data && (method === 'POST' || method === 'PUT' || method === 'PATCH')) {
                    options.body = JSON.stringify(data);
                }
                
                const response = await fetch(url, options);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Alpaca API error (${response.status}): ${errorText}`);
                }
                
                return response.json();
            }
            
            // Account methods
            async getAccount() {
                return this.makeRequest('account');
            }
            
            // Positions methods
            async getPositions() {
                return this.makeRequest('positions');
            }
            
            // Orders methods
            async createOrder(orderData) {
                return this.makeRequest('orders', 'POST', orderData);
            }
            
            async getOrders(status = 'open', limit = 100, after = null, until = null) {
                let params = [`status=${status}`, `limit=${limit}`];
                if (after) params.push(`after=${after}`);
                if (until) params.push(`until=${until}`);
                
                return this.makeRequest(`orders?${params.join('&')}`);
            }
            
            async replaceOrder(orderId, orderData) {
                return this.makeRequest(`orders/${orderId}`, 'PATCH', orderData);
            }
            
            async cancelOrder(orderId) {
                return this.makeRequest(`orders/${orderId}`, 'DELETE');
            }
        }

        // Global Alpaca constructor
        function Alpaca(options) {
            return new AlpacaClient(options);
        }
    </script>
    
    <!-- Additional modal styling -->
    <style>
        /* Modal specific styles */
        #alpaca-modal.modal-wrapper {
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: none;
        }
        
        #alpaca-modal .modal-content {
            background-color: var(--panel-bg, #ffffff);
            color: var(--text, #333333);
            margin: 10% auto;
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        #alpaca-modal .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        
        #alpaca-modal .modal-header h2 {
            margin: 0;
        }
        
        #alpaca-modal .modal-close {
            font-size: 24px;
            cursor: pointer;
        }
        
        #alpaca-modal .modal-tabs {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 1px solid #eee;
        }
        
        #alpaca-modal .modal-tab {
            padding: 10px 15px;
            cursor: pointer;
            margin-right: 5px;
            border-bottom: 2px solid transparent;
        }
        
        #alpaca-modal .modal-tab.active {
            border-bottom: 2px solid var(--primary, #3498db);
        }
        
        #alpaca-modal .modal-tab-content {
            display: none;
            padding: 10px 0;
        }
        
        #alpaca-modal .modal-tab-content.active {
            display: block;
        }
        
        #alpaca-modal .form-group {
            margin-bottom: 15px;
        }
        
        #alpaca-modal .form-group label {
            display: block;
            margin-bottom: 5px;
        }
        
        #alpaca-modal .form-group input {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="header-controls">
        <h1>IQTS AI Trading Dashboard 
            <span id="alpaca-status" class="alpaca-disconnected">Disconnected</span>
            <span id="alpaca-mode" style="display: none;"></span>
        </h1>
        <div class="mode-toggle">
            <button id="dark-mode-toggle" class="toggle-btn dark-toggle">Dark</button>
            <button id="light-mode-toggle" class="toggle-btn light-toggle active-mode">Light</button>
            <button id="paper-mode-toggle" class="toggle-btn" style="background-color: #888888; color: black;">Paper</button>
            <button id="live-mode-toggle" class="toggle-btn" style="background-color: #ffffff; color: black;">Live</button>
        </div>
    </div>
    
    <!-- Market Status Row -->
    <div class="market-status">
        <div class="market-status-indicator" id="market-status-indicator"></div>
        <div class="market-status-info">
            <div id="market-status-text">Loading market status...</div>
            <div class="market-hours" id="market-hours-info"></div>
        </div>
        <div class="market-status-timer" id="market-timer"></div>
    </div>
    
    <!-- Stats Row -->
    <div class="stats-container">
        <!-- Trading Stats -->
        <div class="stats">
            <div class="stat-box">
                <div class="stat-label">Total Trades</div>
                <div class="stat-value" id="total-trades">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Win Rate</div>
                <div class="stat-value" id="win-rate">0%</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Avg. Gain</div>
                <div class="stat-value" id="avg-gain">0%</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Avg. Loss</div>
                <div class="stat-value" id="avg-loss">0%</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Risk/Reward</div>
                <div class="stat-value" id="risk-reward">0.00</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Profit Factor</div>
                <div class="stat-value" id="profit-factor">0.00</div>
            </div>
        </div>
        
        <!-- Alpaca Portfolio Stats -->
        <div class="stats alpaca-stats">
            <div class="stat-box">
                <div class="stat-label">Alpaca Value</div>
                <div class="stat-value" id="alpaca-value">$0.00</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Buying Power</div>
                <div class="stat-value" id="alpaca-buying-power">$0.00</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Today's P/L</div>
                <div class="stat-value" id="alpaca-daily-pl">$0.00</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Open Positions</div>
                <div class="stat-value" id="alpaca-positions">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Cash</div>
                <div class="stat-value" id="alpaca-cash">$0.00</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Cash Withdrawable</div>
                <div class="stat-value" id="alpaca-withdrawable">$0.00</div>
            </div>
        </div>
    </div>
    
    <!-- Automation Control Panel -->
    <div class="panel automation-controls" id="auto-trading-panel">
        <div class="automation-header">
            <h3>Auto-Trading System</h3>
            <div class="automation-status">
                <span class="status-indicator status-disabled" id="auto-status-indicator"></span>
                <span id="auto-trading-status-text">Disabled</span>
            </div>
        </div>
        
        <div class="radar-visualization" id="radar-visualization">
            <div class="radar-scan"></div>
        </div>
        
        <div class="toggle-group" style="justify-content: center; margin: 15px 0;">
            <label>
                <input type="checkbox" id="auto-trading-toggle">
                Enable Auto-Trading
            </label>
        </div>

        <!-- Backend Services Control Panel -->
        <div class="services-panel" id="services-panel">
            <div class="services-header">
                <div class="services-title">
                    <span class="icon-services"></span>
                    <h3>Backend Services</h3>
                    <span id="services-status-indicator" class="status-indicator status-unknown" title="Services status"></span>
                </div>
                <div class="services-actions">
                    <button id="start-all-services" class="service-btn service-start-btn">Start All</button>
                    <button id="stop-all-services" class="service-btn service-stop-btn">Stop All</button>
                </div>
            </div>
            
            <div class="services-list">
                <!-- AI Analysis Service -->
                <div class="service-item">
                    <div class="service-name">AI Analysis Service</div>
                    <div id="aiAnalysis-status" class="service-status status-unknown">Unknown</div>
                    <div class="service-controls">
                        <button id="aiAnalysis-start" class="service-btn service-start-btn"><span class="icon-play"></span> Start</button>
                        <button id="aiAnalysis-stop" class="service-btn service-stop-btn"><span class="icon-stop"></span> Stop</button>
                    </div>
                </div>
                
                <!-- RL Tuning Service -->
                <div class="service-item">
                    <div class="service-name">RL Tuning Service</div>
                    <div id="rlTuning-status" class="service-status status-unknown">Unknown</div>
                    <div class="service-controls">
                        <button id="rlTuning-start" class="service-btn service-start-btn"><span class="icon-play"></span> Start</button>
                        <button id="rlTuning-stop" class="service-btn service-stop-btn"><span class="icon-stop"></span> Stop</button>
                    </div>
                </div>
                
                <!-- Strategy Evolution Service -->
                <div class="service-item">
                    <div class="service-name">Strategy Evolution Service</div>
                    <div id="strategyEvolution-status" class="service-status status-unknown">Unknown</div>
                    <div class="service-controls">
                        <button id="strategyEvolution-start" class="service-btn service-start-btn"><span class="icon-play"></span> Start</button>
                        <button id="strategyEvolution-stop" class="service-btn service-stop-btn"><span class="icon-stop"></span> Stop</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Telegram Status Section -->
        <div class="telegram-status" id="telegram-status-section">
            <div class="telegram-status-header">
                <div class="telegram-status-icon"></div>
                <h3>Telegram Notifications</h3>
                <span class="telegram-badge" style="margin-left: 12px; font-size: 0.75em; background: #ffffff; color: black; padding: 3px 8px; border-radius: 4px; font-weight: bold;">CONNECTED</span>
            </div>
            <div class="telegram-commands">
                <button class="telegram-command" onclick="testTelegramCommand('/status')">/status</button>
                <button class="telegram-command" onclick="testTelegramCommand('/pause')">/pause</button>
                <button class="telegram-command" onclick="testTelegramCommand('/resume')">/resume</button>
                <button class="telegram-command" onclick="testTelegramCommand('/help')">/help</button>
                <button class="telegram-command" onclick="testTelegramCommand('/targets')">/targets</button>
                <button class="telegram-command" onclick="testTelegramCommand('/stats')">/stats</button>
                <button class="telegram-command" onclick="testTelegramCommand('/emergency')">/emergency</button>
            </div>
            <div style="margin-top: 10px;">
                <button class="telegram-command" onclick="testTelegramNotification()" style="background-color: #ffffff; color: black; padding: 8px 15px;">Test Notification</button>
            </div>
        </div>
        
        <!-- Simulation Mode Toggle -->
        <div class="form-group" style="margin: 15px 0; padding: 10px; background-color: #111111; border-radius: 4px; border-left: 4px solid #ffffff;">
            <label class="switch">
                <input type="checkbox" id="simulation-mode">
                <span class="slider"></span>
            </label>
            <span style="margin-left: 10px; font-weight: bold;">Simulation Mode</span>
        </div>
        
        <div class="safety-settings">
            <h4>Risk Management</h4>
            <div class="form-group">
                <label for="max-risk">Max Risk per Trade (%)</label>
                <input type="range" id="max-risk" min="0.1" max="5" step="0.1" value="1">
                <span id="max-risk-value">1%</span>
            </div>
            <div class="form-group">
                <label for="trail-percent">Trailing Stop (%)</label>
                <input type="range" id="trail-percent" min="0.1" max="5" step="0.1" value="1">
                <span id="trail-percent-value">1%</span>
                <div class="slider-feedback" id="trail-percent-feedback"></div>
            </div>
            
            <h4>Profit Targets</h4>
            <div class="form-group profit-targets">
                <input type="checkbox" id="target-2percent" checked>
                <label for="target-2percent">2%</label>
                <input type="checkbox" id="target-4percent" checked>
                <label for="target-4percent">4%</label>
                <input type="checkbox" id="target-6percent">
                <label for="target-6percent">6%</label>
            </div>
        </div>
        
        <!-- Simulation Results Panel -->
        <div class="panel" id="simulation-results">
            <h3>Simulation Results</h3>
            <div class="sim-stats">
                <div>Virtual Balance: <span id="virtual-balance">$10,000.00</span></div>
                <div>Win Rate: <span id="sim-win-rate">0%</span></div>
            </div>
            <button id="run-backtest">Run 30-Day Test</button>
        </div>
        
        <!-- Strategy Comparison Panel -->
        <div class="panel" id="strategy-comparison">
            <h3>Strategy Performance</h3>
            <div class="strategy-tabs">
                <button class="strategy-tab active" data-strategy="swing">Swing</button>
                <button class="strategy-tab" data-strategy="scalp">Scalp</button>
                <button class="strategy-tab" data-strategy="ai-optimized">AI Optimized</button>
            </div>
            <div class="comparison-chart">
                <canvas id="strategyChart"></canvas>
            </div>
        </div>
        
        <!-- ML Predictions Dashboard -->
        <div class="panel" id="ml-predictions">
            <h3>AI Strategy Forecast</h3>
            
            <!-- ML Toggle Switch -->
            <div class="ml-toggle-container">
                <label class="ml-toggle-switch">
                    <input type="checkbox" id="ml-auto-select-toggle">
                    <span class="ml-toggle-slider"></span>
                </label>
                <span class="ml-toggle-label">Auto-Select Strategy</span>
                <span class="ml-toggle-status" id="ml-status-indicator">Disabled</span>
            </div>
            
            <div class="prediction-card">
                <div class="prediction-header">
                    <span id="predicted-strategy">Calculating...</span>
                    <span id="prediction-confidence">--</span>
                </div>
                <div class="factors">
                    <div>
                        VIX Influence: <span id="vix-impact">--</span>
                    </div>
                    <div>
                        Volume Impact: <span id="volume-impact">--</span>
                    </div>
                </div>
                <button id="refresh-prediction">Update Forecast</button>
            </div>
        </div>
        
        <!-- RL Parameter Tuning Panel -->
        <div class="panel" id="rl-tuning">
            <h3>Dynamic Parameter Tuning</h3>
            <div class="param">
                <label>Stop Loss: <span id="current-sl">2%</span></label>
                <div class="param-change">
                    <span id="sl-change" class="neutral">-- 1.8%</span>
                </div>
            </div>
            
            <div class="param">
                <label>Take Profit: <span id="current-tp">5%</span></label>
                <div class="param-change">
                    <span id="tp-change" class="neutral">-- 2.3%</span>
                </div>
            </div>
            
            <div class="param">
                <label>Position Size: <span id="current-ps">2.5%</span></label>
                <div class="param-change">
                    <span id="ps-change" class="neutral">-- 0.5%</span>
                </div>
            </div>
            
            <div class="learning-graph">
                <canvas id="learningProgressChart"></canvas>
            </div>
            
            <div class="rl-controls">
                <button id="tune-now">Tune Parameters Now</button>
            </div>
            
            <div class="auto-tune-container">
                <label class="rl-toggle-switch">
                    <input type="checkbox" id="auto-tune-toggle">
                    <span class="rl-toggle-slider"></span>
                </label>
                <span class="rl-toggle-label">Auto-Tune Parameters</span>
                <span id="rl-status-indicator" class="rl-toggle-status">
                    <span id="rl-status-text">OFF</span>
                </span>
            </div>
        </div>
        
        <!-- Strategy Evolution Panel -->
        <div class="panel" id="strategy-evolution">
            <h3>Strategy Evolution</h3>
            <div class="generation-info">
                Generation: <span id="gen-counter">0</span>
                Best Fitness: <span id="best-fitness">0</span>
            </div>
            <div class="dna-visualization">
                <div class="dna-strand" id="best-dna"></div>
            </div>
            <button id="run-evolution">Run Next Generation</button>
        </div>
        
        <!-- Performance Dashboard -->
        <div class="panel" id="performance-dashboard">
            <h2>Performance Dashboard</h2>
            <div class="metrics">
                <div class="metric">
                    <span class="value" id="win-rate">--</span>
                    <span class="label">Win Rate</span>
                </div>
                <div class="metric">
                    <span class="value" id="avg-hold-time">--</span>
                    <span class="label">Avg Hold Time</span>
                </div>
                <div class="metric">
                    <span class="value" id="avg-profit">--</span>
                    <span class="label">Avg Profit</span>
                </div>
                <div class="metric">
                    <span class="value" id="monthly-gain">--</span>
                    <span class="label">Monthly Gain</span>
                </div>
            </div>
            <button id="refresh-stats">Refresh Data</button>
        </div>
        
                <script>
                    // Direct event handler for the trailing stop slider
                    document.getElementById('trail-percent').oninput = function() {
                        const value = this.value;
                        const feedbackEl = document.getElementById('trail-percent-feedback');
                        document.getElementById('trail-percent-value').textContent = value + '%';
                        
                        // Show feedback animation
                        feedbackEl.textContent = 'Updated to ' + value + '%';
                        feedbackEl.style.opacity = '1';
                        
                        setTimeout(() => {
                            feedbackEl.style.opacity = '0';
                        }, 1500);
                    };
                </script>
            </div>
            <div class="form-group">
                <label for="max-trades">Max Daily Trades</label>
                <input type="range" id="max-trades" min="1" max="20" value="8">
                <span id="max-trades-value">8</span>
            </div>
            <div class="form-group">
                <label for="min-confidence">Min Confidence Level</label>
                <select id="min-confidence">
                    <option value="0.85">Very High (85%)</option>
                    <option value="0.75" selected>High (75%)</option>
                    <option value="0.65">Medium (65%)</option>
                </select>
            </div>
        </div>

        <div class="action-buttons" style="justify-content: center;">
            <button id="pause-auto-trading" class="quick-action-btn">Pause Auto-Trading</button>
            <button id="view-auto-trades" class="quick-action-btn">View Auto-Trades</button>
        </div>

        <div class="auto-stats-grid">
            <div class="auto-stat-card">
                <div class="stat-label">Today's Trades</div>
                <div class="auto-stat-value" id="today-trades-count">0</div>
            </div>
            <div class="auto-stat-card">
                <div class="stat-label">Success Rate</div>
                <div class="auto-stat-value" id="auto-trade-success">0%</div>
            </div>
            <div class="auto-stat-card">
                <div class="stat-label">Avg. P/L</div>
                <div class="auto-stat-value" id="auto-trade-pl">0%</div>
            </div>
            <div class="auto-stat-card">
                <div class="stat-label">Active Trades</div>
                <div class="auto-stat-value" id="active-auto-trades">0</div>
            </div>
        </div>

        <div id="auto-trade-stats" style="margin-top: 15px;">
            <p><strong>Today's Auto-Trades:</strong> <span id="today-trades-count">0</span></p>
            <p><strong>Auto-Trade Success Rate:</strong> <span id="auto-trade-success">0%</span></p>
            <p><strong>Avg. Auto-Trade P/L:</strong> <span id="auto-trade-pl">0%</span></p>
        </div>
    </div>
    
    <!-- Portfolio Summary -->
    <div class="portfolio-summary" id="portfolio-summary">
        <h3>Alpaca Portfolio: <span id="portfolio-mode-display">Not Connected</span></h3>
        <div id="portfolio-content">
            <p>Connect to Alpaca to view portfolio data</p>
        </div>
    </div>
    
    <!-- Chart Panel -->
    <div class="panel">
        <div class="chart-controls">
            <button id="resize-chart-btn" class="quick-action-btn">Resize Chart</button>
            <button id="fullscreen-chart-btn" class="quick-action-btn">Full Screen</button>
        </div>
        <div id="tradingview-chart"></div>
    </div>
    
    <!-- Signals and Strategy Panel -->
    <div class="panel">
        <div class="strategy-switcher">
            <h3>Current Signals 
                <select id="strategy-selector" style="margin-left: 10px; padding: 5px;">
                    <option value="swing">Swing (1-5 days)</option>
                    <option value="scalp">Scalp (Intraday)</option>
                </select>
            </h3>
        </div>
        
        <div id="ai-signals">
          <div class="signals-container" id="signals-container">
            <!-- Signals will load here -->
          </div>
        </div>
        
        <div class="strategy-info-toggle" id="strategy-info-toggle">
            <span>Strategy Info</span>
            <span>▼</span>
        </div>
        
        <div class="strategy-info-content" id="strategy-info-content">
            <p><strong>Strategy:</strong> <span id="current-strategy-display">Swing Trading (Hold 1–5 Days)</span></p>
            <p><strong>Timeframe:</strong> <span id="current-timeframe">30-min / 1H / Daily charts</span></p>
            <p><strong>Target:</strong> <span id="current-target">5–10% gains</span></p>
            <p><strong>Stop loss:</strong> <span id="current-stop">2–3%</span></p>
            <p><strong>Indicators:</strong></p>
            <ul id="current-indicators">
                <li>MACD crossover</li>
                <li>RSI < 40 = buy zone</li>
                <li>Support/Resistance trendlines</li>
            </ul>
            <p><strong>Candidates:</strong> <span id="current-candidates">NIO, PLTR, RIVN, FUBO, MARA</span></p>
            <p><strong>Look for:</strong> <span id="current-lookfor">Oversold small-cap tech stocks</span></p>
        </div>
    </div>
    
    <!-- Main Content Container -->
    <div class="container">
        <!-- Left Column -->
        <div class="panel">
            <h2>Active Trades</h2>
            <table id="active-trades">
                <thead>
                    <tr>
                        <th>Symbol</th>
                        <th>Entry</th>
                        <th>Current</th>
                        <th>Size</th>
                        <th>P/L %</th>
                        <th>Chart</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Active trades will be added here -->
                </tbody>
            </table>
            <div class="action-buttons">
                <button id="add-trade-btn">Add New Trade</button>
                <button id="export-csv">Export to CSV</button>
                <button id="import-csv">Import from CSV</button>
                <input type="file" id="csv-file" accept=".csv" style="display: none;">
                <button id="connect-alpaca">Connect Alpaca</button>
                <button id="refresh-portfolio">Refresh Portfolio</button>
            </div>
            
            <div id="trade-form" style="display: none; margin-top: 20px;">
                <h3>Add/Edit Trade</h3>
                <form id="trade-data-form">
                    <input type="hidden" id="trade-id">
                    <div class="form-group">
                        <label for="symbol">Symbol (e.g., BTCUSDT, AAPL)</label>
                        <input type="text" id="symbol" required>
                    </div>
                    <div class="form-group">
                        <label for="direction">Direction</label>
                        <select id="direction" required>
                            <option value="Long">Long</option>
                            <option value="Short">Short</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="entry-price">Entry Price</label>
                        <input type="number" id="entry-price" step="0.0001" required>
                    </div>
                    <div class="form-group">
                        <label for="current-price">Current Price</label>
                        <input type="number" id="current-price" step="0.0001" required>
                    </div>
                    <div class="form-group">
                        <label for="position-size">Position Size ($)</label>
                        <input type="number" id="position-size" step="0.01" required>
                    </div>
                    <div class="form-group">
                        <label for="stop-loss">Stop Loss (2-3%)</label>
                        <input type="number" id="stop-loss" step="0.0001">
                    </div>
                    <div class="form-group">
                        <label for="take-profit">Take Profit (5-10%)</label>
                        <input type="number" id="take-profit" step="0.0001">
                    </div>
                    <div class="form-group">
                        <label for="chart-link">Chart Link</label>
                        <input type="text" id="chart-link" placeholder="https://www.tradingview.com/chart/...">
                    </div>
                    <div class="form-group">
                        <label for="notes">Notes</label>
                        <textarea id="notes" rows="3"></textarea>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <input type="submit" value="Save Trade">
                        <button type="button" id="cancel-trade-btn">Cancel</button>
                    </div>
                </form>
            </div>
        </div>
        
        <!-- Right Column -->
        <div class="panel">
            <h2>Watchlist</h2>
            <div class="form-group" style="display: flex;">
                <input type="text" id="new-watchlist-item" placeholder="Add symbol (e.g., BTCUSD, AAPL)" style="flex: 1; margin-right: 10px;">
                <button id="add-to-watchlist">Add</button>
            </div>
            <div id="watchlist-items">
                <!-- Watchlist items will be added here -->
            </div>
            
            <h2 style="margin-top: 30px;">Trade History</h2>
            <div class="tabs">
                <div class="tab active" data-tab="all">All Trades</div>
                <div class="tab" data-tab="winners">Winners</div>
                <div class="tab" data-tab="losers">Losers</div>
                <div class="tab" data-tab="equity">Equity Curve</div>
            </div>
            
            <div class="tab-content active" id="all-trades">
                <table id="trade-history">
                    <thead>
                        <tr>
                            <th>Symbol</th>
                            <th>Direction</th>
                            <th>Entry</th>
                            <th>Exit</th>
                            <th>Size</th>
                            <th>P/L %</th>
                            <th>P/L $</th>
                            <th>Date</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Trade history will be added here -->
                    </tbody>
                </table>
            </div>
            
            <div class="tab-content" id="winners-trades">
                <table>
                    <thead>
                        <tr>
                            <th>Symbol</th>
                            <th>Direction</th>
                            <th>Entry</th>
                            <th>Exit</th>
                            <th>Size</th>
                            <th>P/L %</th>
                            <th>P/L $</th>
                            <th>Date</th>
                        </tr>
                    </thead>
                    <tbody id="winners-body">
                <table>
                    <thead>
                        <tr>
                            <th>Symbol</th>
                            <th>Direction</th>
                            <th>Entry</th>
                            <th>Exit</th>
                            <th>Size</th>
                            <th>P/L %</th>
                            <th>P/L $</th>
                            <th>Date</th>
                        </tr>
                    </thead>
                    <tbody id="winners-body">
                        <!-- Winning trades will be added here -->
                    </tbody>
                </table>
            </div>
            
            <div class="tab-content" id="losers-trades">
                <table>
                    <thead>
                        <tr>
                            <th>Symbol</th>
                            <th>Direction</th>
                            <th>Entry</th>
                            <th>Exit</th>
                            <th>Size</th>
                            <th>P/L %</th>
                            <th>P/L $</th>
                            <th>Date</th>
                        </tr>
                    </thead>
                    <tbody id="losers-body">
                <table>
                    <thead>
                        <tr>
                            <th>Symbol</th>
                            <th>Direction</th>
                            <th>Entry</th>
                            <th>Exit</th>
                            <th>Size</th>
                            <th>P/L %</th>
                            <th>P/L $</th>
                            <th>Date</th>
                        </tr>
                    </thead>
                    <tbody id="losers-body">
                        <!-- Losing trades will be added here -->
                    </tbody>
                </table>
            </div>
            
            <div class="tab-content" id="equity-trades">
                <div id="equity-chart" style="height: 300px; margin-top: 10px;">
                    <label for="live-key">API Key ID</label>
                    <input type="text" id="live-key" placeholder="Enter your live trading API key">
                </div>
                <div class="form-group">
                    <label for="live-secret">Secret Key</label>
                    <input type="password" id="live-secret" placeholder="Enter your live trading secret key">
                </div>
                <button id="connect-live" class="sell-btn" style="width: 100%;">Connect Live Account</button>
            </div>
        </div>
    </div>

    <!-- Auto-Trade History Modal -->
    <div id="auto-trade-history-modal" class="modal-wrapper">
        <div class="modal-content">
            <span class="close-modal">&times;</span>
            <h2>Automated Trade History</h2>
            <div class="trade-history-table">
                <div class="trade-history-header">
                    <div>Symbol / Date</div>
                    <div>Type</div>
                    <div>Price</div>
                    <div>Qty</div>
                    <div>Confidence</div>
                    <div>Result</div>
                </div>
                <div id="auto-trade-history-content">
                    <!-- Auto trade history will be populated here -->
                </div>
            </div>
            <button id="close-auto-trade-history" class="quick-action-btn" style="margin-top: 20px;">Close</button>
        </div>
    </div>

    <script>
        /**
         * AutoTrader class for automated trading functionality
         */
        class AutoTrader {
            constructor() {
                // Initialize properties
                this.enabled = false;
                this.trailingStops = new Map(); // Tracks active trailing stops
                this.volatilityCache = new Map(); // Stores ATR values
                this.dailyTrades = 0;
                this.lastTradeTime = null;
                this.marketStatus = {
                    vix: 20,
                    isTrendDay: false
                };
                
                // Load saved settings
                this.loadSettings();
            }
            
            loadSettings() {
                try {
                    const savedSettings = localStorage.getItem('autoTraderSettings');
                    if (savedSettings) {
                        const settings = JSON.parse(savedSettings);
                        this.settings = {
                            ...this.getDefaultSettings(),
                            ...settings
                        };
                    } else {
                        this.settings = this.getDefaultSettings();
                    }
                } catch (error) {
                    console.error('Error loading AutoTrader settings:', error);
                    this.settings = this.getDefaultSettings();
                }
            }
            
            saveSettings() {
                try {
                    localStorage.setItem('autoTraderSettings', JSON.stringify(this.settings));
                } catch (error) {
                    console.error('Error saving AutoTrader settings:', error);
                }
            }
            
            getDefaultSettings() {
                return {
                    // Risk Management
                    maxRiskPerTrade: 0.01,     // Risk 1% of capital per trade
                    maxDailyTrades: 8,         // Limit to 8 trades/day
                    maxPositionSize: 0.15,     // No more than 15% in any single position
                    minConfidence: 0.75,       // Only trade signals with ≥75% confidence
                    trailPercent: 0.01,        // 1% trailing stop default
                    
                    // Strategy-Specific
                    swing: {
                        stopLoss: 0.97,          // 3% stop loss
                        takeProfit: 1.08,        // 8% target
                        minRSI: 35,              // Don't buy if RSI > 35
                        holdPeriod: '2-5 days'   // Average holding period
                    },
                    scalp: {
                        stopLoss: 0.995,         // 0.5% stop loss
                        takeProfit: 1.02,        // 2% target  
                        minRSI: 28,              // More oversold threshold
                        holdPeriod: '5-30 mins'  // Quick trades
                    },
                    
                    // Signal Quality Filters
                    volumeMultiplier: 2.3,     // Require 2.3x average volume
                    trendConfirmDays: 3,       // Require 3-day trend confirmation
                    
                    // Market conditions
                    maxVIX: 30,                // Don't trade if VIX > 30
                    minLiquidity: 1000000,     // Minimum $1M daily volume
                    
                    // Trailing stops
                    useTrailingStops: true,
                    trailPercent: 0.015        // 1.5% trailing stop after +5% profit
                };
            }
            
            toggleAutoTrading(enable) {
                this.enabled = enable;
                if (enable) {
                    this.resetDailyStats();
                    console.log('Auto-trading enabled with settings:', this.settings);
                    // Show notification
                    showNotification('Auto-Trading Activated', 'Automatic trading has been enabled. The system will now place trades based on your risk parameters.', 'info');
                } else {
                    console.log('Auto-trading disabled');
                    showNotification('Auto-Trading Disabled', 'Automatic trading has been turned off. No new trades will be placed automatically.', 'info');
                }
                return this.enabled;
            }
            
            resetDailyStats() {
                const today = new Date().toDateString();
                const lastResetDay = localStorage.getItem('lastAutoTradeResetDay');
                
                if (lastResetDay !== today) {
                    this.dailyTrades = 0;
                    localStorage.setItem('lastAutoTradeResetDay', today);
                    localStorage.setItem('dailyAutoTrades', '0');
                } else {
                    const savedDailyTrades = localStorage.getItem('dailyAutoTrades');
                    this.dailyTrades = savedDailyTrades ? parseInt(savedDailyTrades) : 0;
                }
            }
            
            canPlaceTrade(confidenceScore) {
                if (!this.enabled) return false;
                
                // Check daily trade limit
                if (this.dailyTrades >= this.settings.maxDailyTrades) {
                    console.log('Daily trade limit reached');
                    return false;
                }
                
                // Check confidence threshold
                if (confidenceScore < this.settings.minConfidence) {
                    console.log(`Signal confidence (${confidenceScore}) below threshold (${this.settings.minConfidence})`);
                    return false;
                }
                
                // Check VIX level
                if (this.marketStatus.vix > this.settings.maxVIX) {
                    console.log(`VIX too high (${this.marketStatus.vix})`);
                    return false;
                }
                
                // Check trading hours
                const now = new Date();
                const hours = now.getHours() + now.getMinutes() / 60;
                const tradingHours = {
                    start: 9.5,  // 9:30 AM ET
                    end: 16      // 4:00 PM ET
                };
                
                if (hours < tradingHours.start || hours > tradingHours.end) {
                    console.log('Outside regular trading hours');
                    return false;
                }
                
                // Prevent excessive trading frequency
                if (this.lastTradeTime) {
                    const minTimeBetweenTrades = 5 * 60 * 1000; // 5 minutes in milliseconds
                    const elapsedTime = now - this.lastTradeTime;
                    if (elapsedTime < minTimeBetweenTrades) {
                        console.log('Trade frequency limit reached');
                        return false;
                    }
                }
                
                return true;
            }
            
            calculatePositionSize(symbol, entryPrice, stopPrice, account) {
                // Get ATR (Average True Range) for volatility adjustment
                const atr = this.getATR(symbol) || (entryPrice * 0.01); // Default to 1% of price if ATR unknown
                
                // Apply volatility adjustment (more volatile = smaller position)
                const volatilityAdjustment = Math.min(atr / entryPrice, 0.05); // Cap at 5%
                
                // Calculate risk per share with volatility adjustment
                const riskPerShare = Math.abs(entryPrice - stopPrice) * (1 + volatilityAdjustment);
                
                // Calculate maximum risk amount based on account size
                const maxRiskAmount = account.portfolio_value * this.settings.maxRiskPerTrade;
                
                // Calculate position size based on risk
                const shares = Math.floor(maxRiskAmount / riskPerShare);
                
                // Check against max position size limit
                const maxPositionValue = account.portfolio_value * this.settings.maxPositionSize;
                const maxShares = Math.floor(maxPositionValue / entryPrice);
                
                // Return the smaller of the two
                return Math.min(shares, maxShares);
            }
            
            getATR(symbol, period = 14) {
                // Return cached ATR if available
                if (this.volatilityCache.has(symbol)) {
                    return this.volatilityCache.get(symbol);
                }
                return null; // ATR calculation would need historical data
            }
            
            manageOpenPosition(symbol, entryPrice, type, order) {
                if (!this.settings.useTrailingStops) return;
                
                const currentPrice = this.getCurrentPrice(symbol);
                if (!currentPrice) return;
                
                // Calculate trail distance based on strategy
                const trailDistance = this.settings.trailPercent;
                
                // Initialize trailing stop if new position
                if (!this.trailingStops.has(symbol)) {
                    this.trailingStops.set(symbol, {
                        highestPrice: type === 'buy' ? entryPrice : Infinity,
                        lowestPrice: type === 'sell' ? entryPrice : 0
                    });
                }
                
                const trailData = this.trailingStops.get(symbol);
                
                // Update price extremes and check for stop move
                if (type === 'buy') {
                    // For long positions, track highest price
                    const prevHighest = trailData.highestPrice;
                    trailData.highestPrice = Math.max(trailData.highestPrice, currentPrice);
                    
                    // Only move stop up if price has reached 5% profit and is still rising
                    if (currentPrice >= entryPrice * 1.05 && trailData.highestPrice > prevHighest) {
                        const stopPrice = trailData.highestPrice * (1 - trailDistance);
                        
                        // Move stop up if new stop is higher than current stop
                        if (!order.stop_price || stopPrice > order.stop_price) {
                            this.updateStopOrder(symbol, stopPrice, order.id);
                        }
                    }
                } else {
                    // For short positions, track lowest price
                    const prevLowest = trailData.lowestPrice;
                    trailData.lowestPrice = Math.min(trailData.lowestPrice, currentPrice);
                    
                    // Only move stop down if price has reached 5% profit and is still falling
                    if (currentPrice <= entryPrice * 0.95 && trailData.lowestPrice < prevLowest) {
                        const stopPrice = trailData.lowestPrice * (1 + trailDistance);
                        
                        // Move stop down if new stop is lower than current stop
                        if (!order.stop_price || stopPrice < order.stop_price) {
                            this.updateStopOrder(symbol, stopPrice, order.id);
                        }
                    }
                }
            }
            
            getCurrentPrice(symbol) {
                try {
                    const watchlistItem = document.querySelector(`.watchlist-item[data-symbol="${symbol}"] .price`);
                    if (watchlistItem) {
                        const priceText = watchlistItem.textContent;
                        return parseFloat(priceText.replace(/[^0-9.-]+/g, ''));
                    }
                    return null;
                } catch (error) {
                    console.error('Error getting current price:', error);
                    return null;
                }
            }
            
            async updateStopOrder(symbol, stopPrice, orderId) {
                if (!alpacaClient) return;
                
                try {
                    // This would need to use your Alpaca client to update the stop order
                    if (alpacaConnected) {
                        // Using the alpacaClient makeRequest method directly
                        await alpacaClient.makeRequest(`orders/${orderId}`, 'PATCH', {
                            stop_price: stopPrice.toFixed(2)
                        });
                        console.log(`Updated trailing stop for ${symbol} to $${stopPrice.toFixed(2)}`);
                        showNotification(
                            'Trailing Stop Updated', 
                            `${symbol} stop moved to $${stopPrice.toFixed(2)}`, 
                            'info'
                        );
                    }
                } catch (error) {
                    console.error('Error updating stop order:', error);
                }
            }
            
            calculateSignalConfidence(signal) {
                let confidence = 0;
                const strategyType = signal.strategy || 'swing';
                
                // Base components (sum to 0.8 max)
                confidence += (signal.rsi < this.settings[strategyType].minRSI) ? 0.3 : 0;
                confidence += (signal.volume > signal.avgVolume * this.settings.volumeMultiplier) ? 0.25 : 0;
                confidence += (signal.trendConfirmed) ? 0.2 : 0;
                
                // Market context adjustments (sum to 0.2 max)
                confidence += (this.marketStatus.vix < 20) ? 0.1 : 0;    // Bonus in calm markets
                confidence += (this.marketStatus.isTrendDay) ? 0.1 : 0;  // Bonus in strong trends
                
                // Time of day adjustment
                const hour = new Date().getHours();
                confidence += (hour >= 10 && hour <= 15) ? 0.1 : 0;      // Best trading hours
                
                return Math.min(1, confidence);
            }
            
            async placeTrade(signal) {
                if (!this.canPlaceTrade(signal.confidence)) {
                    return null;
                }
                
                try {
                    if (!alpacaConnected) {
                        console.error('Alpaca not connected');
                        return null;
                    }
                    
                    // Get account info to calculate position size
                    const account = await alpacaClient.makeRequest('account');
                    
                    // Calculate stop price and position size
                    const stopPrice = signal.type === 'buy' 
                        ? signal.price * this.settings[signal.strategy || 'swing'].stopLoss
                        : signal.price * (2 - this.settings[signal.strategy || 'swing'].stopLoss);
                        
                    const qty = this.calculatePositionSize(signal.symbol, signal.price, stopPrice, account);
                    
                    if (!qty || qty < 1) {
                        console.log(`Position size too small for ${signal.symbol}`);
                        return null;
                    }
                    
                    // Create order object
                    const orderParams = {
                        symbol: signal.symbol,
                        qty: qty.toString(),
                        side: signal.type.toLowerCase(),
                        type: 'market',
                        time_in_force: 'day'
                    };
                    
                    // Place main order
                    const order = await alpacaClient.makeRequest('orders', 'POST', orderParams);
                    
                    // Place stop loss order
                    const stopOrderParams = {
                        symbol: signal.symbol,
                        qty: qty.toString(),
                        side: signal.type.toLowerCase() === 'buy' ? 'sell' : 'buy',
                        type: 'stop',
                        time_in_force: 'gtc',
                        stop_price: stopPrice.toFixed(2)
                    };
                    
                    const stopOrder = await alpacaClient.makeRequest('orders', 'POST', stopOrderParams);
                    
                    // Record trade
                    this.lastTradeTime = new Date();
                    
                    // Send Telegram notification
                    if (typeof TelegramService !== 'undefined') {
                        await TelegramService.send(
                            `${signal.type.toUpperCase()} ${signal.symbol} ${qty} @ ${order.filled_avg_price || signal.price}`
                        );
                    }
                    this.dailyTrades++;
                    localStorage.setItem('dailyAutoTrades', this.dailyTrades.toString());
                    
                    // Show notification
                    showNotification(
                        `Auto-${signal.type.toUpperCase()} Order Placed`,
                        `${signal.symbol}: ${qty} shares at $${signal.price}`,
                        signal.type.toLowerCase()
                    );
                    
                    // Log the trade
                    tradeLogger.logTrade({
                        symbol: signal.symbol,
                        type: signal.type,
                        price: signal.price,
                        quantity: qty,
                        stopPrice: stopPrice,
                        confidence: signal.confidence,
                        timestamp: new Date(),
                        orderId: order.id,
                        stopOrderId: stopOrder.id,
                        strategy: signal.strategy || 'swing',
                        isAuto: true
                    });
                    
                    return {
                        order,
                        stopOrder
                    };
                } catch (error) {
                    console.error('Error placing automated trade:', error);
                    return null;
                }
            }
            
            updateMarketStatus() {
                // Update VIX
                fetchVIX().then(vix => {
                    this.marketStatus.vix = vix;
                });
                
                // Check if it's a trend day
                checkTrendDay().then(isTrendDay => {
                    this.marketStatus.isTrendDay = isTrendDay;
                });
            }
        }

        /**
         * TradeLogger class for tracking and logging trades
         */
        class TradeLogger {
            constructor() {
                this.trades = [];
                this.loadTrades();
            }
            
            loadTrades() {
                try {
                    const savedTrades = localStorage.getItem('autoTradeLogs');
                    if (savedTrades) {
                        this.trades = JSON.parse(savedTrades);
                        // Convert string dates back to Date objects
                        this.trades.forEach(trade => {
                            trade.timestamp = new Date(trade.timestamp);
                            if (trade.closeTimestamp) {
                                trade.closeTimestamp = new Date(trade.closeTimestamp);
                            }
                        });
                    }
                } catch (error) {
                    console.error('Error loading trade logs:', error);
                    this.trades = [];
                }
            }
            
            saveTrades() {
                try {
                    localStorage.setItem('autoTradeLogs', JSON.stringify(this.trades));
                } catch (error) {
                    console.error('Error saving trade logs:', error);
                }
            }
            
            logTrade(tradeData) {
                this.trades.push({
                    ...tradeData,
                    id: Date.now().toString(), // Generate unique ID
                    status: 'open'
                });
                this.saveTrades();
                
                // Also add to the regular trades array if we're maintaining both
                trades.push({
                    id: Date.now().toString(),
                    symbol: tradeData.symbol,
                    type: tradeData.type,
                    entry: tradeData.price,
                    exit: null,
                    size: tradeData.quantity,
                    entryDate: new Date(),
                    exitDate: null,
                    pl: 0,
                    plPercent: 0,
                    status: 'open',
                    notes: 'Auto-generated trade',
                    strategy: tradeData.strategy,
                    isAuto: true
                });
                localStorage.setItem('trades', JSON.stringify(trades));
                
                // Update UI if necessary
                this.updateTradeStatistics();
                updateTradeStats(); // The global function to update trade stats
            }
            
            closeTrade(tradeId, closePrice) {
                const tradeIndex = this.trades.findIndex(t => t.id === tradeId);
                if (tradeIndex !== -1) {
                    const trade = this.trades[tradeIndex];
                    
                    // Calculate P/L
                    const isLong = trade.type.toLowerCase() === 'buy';
                    const pl = isLong 
                        ? closePrice / trade.price - 1 
                        : 1 - closePrice / trade.price;
                    
                    // Update trade data
                    this.trades[tradeIndex] = {
                        ...trade,
                        status: 'closed',
                        closePrice,
                        closeTimestamp: new Date(),
                        pl: pl // As a decimal (0.05 = 5% gain)
                    };
                    
                    this.saveTrades();
                    this.updateTradeStatistics();
                    
                    // Also update in the global trades array
                    const globalTradeIndex = trades.findIndex(t => 
                        t.isAuto && 
                        t.symbol === trade.symbol && 
                        t.entry === trade.price && 
                        new Date(t.entryDate).getTime() === new Date(trade.timestamp).getTime()
                    );
                    
                    if (globalTradeIndex !== -1) {
                        trades[globalTradeIndex].exit = closePrice;
                        trades[globalTradeIndex].exitDate = new Date();
                        trades[globalTradeIndex].status = 'closed';
                        trades[globalTradeIndex].plPercent = pl * 100;
                        trades[globalTradeIndex].pl = (closePrice - trades[globalTradeIndex].entry) * trades[globalTradeIndex].size;
                        localStorage.setItem('trades', JSON.stringify(trades));
                        updateTradeStats(); // Update global trade stats
                    }
                    
                    return this.trades[tradeIndex];
                }
                return null;
            }
            
            getTodaysTrades() {
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                
                return this.trades.filter(trade => 
                    new Date(trade.timestamp) >= today
                );
            }
            
            getAutoTrades() {
                return this.trades.filter(trade => 
                    trade.isAuto === true
                );
            }
            
            getTodaysAutoTrades() {
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                
                return this.trades.filter(trade => 
                    new Date(trade.timestamp) >= today && 
                    trade.isAuto === true
                );
            }
            
            getSuccessRate(autoOnly = false) {
                const filteredTrades = autoOnly 
                    ? this.trades.filter(t => t.isAuto === true && t.status === 'closed')
                    : this.trades.filter(t => t.status === 'closed');
                
                if (filteredTrades.length === 0) return 0;
                
                const successfulTrades = filteredTrades.filter(t => t.pl > 0);
                return successfulTrades.length / filteredTrades.length;
            }
            
            getAveragePL(autoOnly = false) {
                const filteredTrades = autoOnly 
                    ? this.trades.filter(t => t.isAuto === true && t.status === 'closed')
                    : this.trades.filter(t => t.status === 'closed');
                
                if (filteredTrades.length === 0) return 0;
                
                const totalPL = filteredTrades.reduce((sum, t) => sum + t.pl, 0);
                return totalPL / filteredTrades.length;
            }
            
            updateTradeStatistics() {
                // Update the UI with trade statistics
                const todayAutoCounts = this.getTodaysAutoTrades().length;
                const successRate = this.getSuccessRate(true);
                const avgPL = this.getAveragePL(true);
                
                // Update UI elements if they exist
                document.getElementById('today-trades-count').textContent = todayAutoCounts;
                document.getElementById('auto-trade-success').textContent = `${(successRate * 100).toFixed(1)}%`;
                document.getElementById('auto-trade-pl').textContent = `${(avgPL * 100).toFixed(2)}%`;
            }
            
            getTradeHistory() {
                // Return a copy of the trades array sorted by date (newest first)
                return [...this.trades].sort((a, b) => 
                    new Date(b.timestamp) - new Date(a.timestamp)
                );
            }
        }

        /**
         * Generate trading signals based on technical analysis
         */
        function generateAISignals(symbol, priceData, options = {}) {
            const { strategy = 'swing', confidence = 0.75 } = options;
            
            if (!priceData || priceData.length < 30) {
                console.log(`Insufficient data for ${symbol} signal generation`);
                return null;
            }
            
            try {
                // Calculate technical indicators
                const rsi = calculateRSI(priceData.map(d => d.close));
                const macd = calculateMACD(priceData.map(d => d.close));
                const bb = calculateBollingerBands(priceData.map(d => d.close));
                
                // Get latest values
                const latestPrice = priceData[priceData.length - 1].close;
                const latestVolume = priceData[priceData.length - 1].volume || 0;
                
                // Calculate average volume (20-day)
                const avgVolume = priceData
                    .slice(-20)
                    .reduce((sum, candle) => sum + (candle.volume || 0), 0) / 20;
                
                // Determine trend direction
                const trendConfirmed = checkTrendConfirmation(priceData.map(d => d.close));
                
                // Signal generator properties
                const signalProps = {
                    symbol,
                    price: latestPrice,
                    volume: latestVolume,
                    avgVolume: avgVolume,
                    rsi: rsi[rsi.length - 1],
                    macdLine: macd.macdLine[macd.macdLine.length - 1],
                    macdSignal: macd.signalLine[macd.signalLine.length - 1],
                    upperBB: bb.upper[bb.upper.length - 1],
                    middleBB: bb.middle[bb.middle.length - 1],
                    lowerBB: bb.lower[bb.lower.length - 1],
                    trendConfirmed: trendConfirmed,
                    strategy: strategy
                };
                
                // Generate signal and calculate confidence
                let signal = null;
                
                // Define strategy thresholds
                const thresholds = strategy === 'swing' ? {
                    rsiOversold: 35,
                    rsiOverbought: 70,
                    volumeMultiplier: 2.0
                } : {
                    rsiOversold: 28,
                    rsiOverbought: 75,
                    volumeMultiplier: 3.0
                };
                
                // Buy signal conditions
                if (
                    signalProps.rsi <= thresholds.rsiOversold &&
                    signalProps.macdLine > signalProps.macdSignal - 0.05 &&
                    signalProps.price < signalProps.middleBB * 0.95 &&
                    signalProps.volume >= signalProps.avgVolume * thresholds.volumeMultiplier
                ) {
                    signal = {
                        symbol: signalProps.symbol,
                        type: 'buy',
                        price: signalProps.price,
                        volume: signalProps.volume,
                        avgVolume: signalProps.avgVolume,
                        rsi: signalProps.rsi,
                        confidence: 0,  // Will calculate this below
                        timestamp: new Date(),
                        strategy: signalProps.strategy,
                        trendConfirmed: signalProps.trendConfirmed
                    };
                }
                // Sell signal conditions
                else if (
                    signalProps.rsi >= thresholds.rsiOverbought &&
                    signalProps.macdLine < signalProps.macdSignal + 0.05 &&
                    signalProps.price > signalProps.middleBB * 1.05 &&
                    signalProps.volume >= signalProps.avgVolume * thresholds.volumeMultiplier
                ) {
                    signal = {
                        symbol: signalProps.symbol,
                        type: 'sell',
                        price: signalProps.price,
                        volume: signalProps.volume,
                        avgVolume: signalProps.avgVolume,
                        rsi: signalProps.rsi,
                        confidence: 0,  // Will calculate this below
                        timestamp: new Date(),
                        strategy: signalProps.strategy,
                        trendConfirmed: signalProps.trendConfirmed
                    };
                }
                
                // If we have a signal, calculate confidence
                if (signal) {
                    let confidenceScore = 0;
                    
                    // RSI component (30%)
                    if (signal.type === 'buy') {
                        const rsiScore = signal.rsi < 30 ? 1 : signal.rsi < 40 ? 0.8 : signal.rsi < 50 ? 0.5 : 0;
                        confidenceScore += rsiScore * 0.3;
                    } else {
                        const rsiScore = signal.rsi > 70 ? 1 : signal.rsi > 65 ? 0.8 : signal.rsi > 60 ? 0.5 : 0;
                        confidenceScore += rsiScore * 0.3;
                    }
                    
                    // Volume component (25%)
                    const volumeRatio = signal.volume / signal.avgVolume;
                    const volumeScore = volumeRatio > 3 ? 1 : volumeRatio > 2 ? 0.8 : volumeRatio > 1.5 ? 0.6 : 0.3;
                    confidenceScore += volumeScore * 0.25;
                    
                    // Trend component (20%)
                    confidenceScore += (signal.trendConfirmed ? 1 : 0) * 0.2;
                    
                    // MACD component (15%)
                    if (signal.type === 'buy') {
                        const macdScore = signalProps.macdLine > signalProps.macdSignal ? 1 : 
                                        signalProps.macdLine > signalProps.macdSignal - 0.1 ? 0.5 : 0;
                        confidenceScore += macdScore * 0.15;
                    } else {
                        const macdScore = signalProps.macdLine < signalProps.macdSignal ? 1 : 
                                        signalProps.macdLine < signalProps.macdSignal + 0.1 ? 0.5 : 0;
                        confidenceScore += macdScore * 0.15;
                    }
                    
                    // Bollinger Bands component (10%)
                    if (signal.type === 'buy') {
                        const bbScore = signalProps.price < signalProps.lowerBB * 1.05 ? 1 : 
                                      signalProps.price < signalProps.middleBB * 0.95 ? 0.7 : 
                                      signalProps.price < signalProps.middleBB ? 0.3 : 0;
                        confidenceScore += bbScore * 0.1;
                    } else {
                        const bbScore = signalProps.price > signalProps.upperBB * 0.95 ? 1 : 
                                      signalProps.price > signalProps.middleBB * 1.05 ? 0.7 : 
                                      signalProps.price > signalProps.middleBB ? 0.3 : 0;
                        confidenceScore += bbScore * 0.1;
                    }
                    
                    signal.confidence = confidenceScore;
                    
                    // Apply confidence threshold
                    if (signal.confidence >= confidence) {
                        return signal;
                    }
                }
                
                return null;
            } catch (error) {
                console.error('Error generating signals:', error);
                return null;
            }
        }

        /**
         * Calculate RSI (Relative Strength Index)
         */
        function calculateRSI(prices, period = 14) {
            const rsi = [];
            
            // Seed with null values for initial period
            for (let i = 0; i < period; i++) {
                rsi.push(null);
            }
            
            let avgGain = 0;
            let avgLoss = 0;
            
            // First RSI calculation
            for (let i = 1; i <= period; i++) {
                const change = prices[i] - prices[i - 1];
                if (change > 0) {
                    avgGain += change / period;
                } else {
                    avgLoss += Math.abs(change) / period;
                }
            }
            
            let rs = avgGain / (avgLoss === 0 ? 0.001 : avgLoss);
            rsi.push(100 - (100 / (1 + rs)));
            
            // Rest of RSI calculation
            for (let i = period + 1; i < prices.length; i++) {
                const change = prices[i] - prices[i - 1];
                const gain = change > 0 ? change : 0;
                const loss = change < 0 ? Math.abs(change) : 0;
                
                avgGain = ((period - 1) * avgGain + gain) / period;
                avgLoss = ((period - 1) * avgLoss + loss) / period;
                
                rs = avgGain / (avgLoss === 0 ? 0.001 : avgLoss);
                rsi.push(100 - (100 / (1 + rs)));
            }
            
            return rsi;
        }

        /**
         * Calculate MACD (Moving Average Convergence Divergence)
         */
        function calculateMACD(prices, fastLength = 12, slowLength = 26, signalLength = 9) {
            const ema12 = calculateEMA(prices, fastLength);
            const ema26 = calculateEMA(prices, slowLength);
            const macdLine = [];
            
            // Calculate MACD Line
            for (let i = 0; i < prices.length; i++) {
                if (i < fastLength - 1 || i < slowLength - 1) {
                    macdLine.push(null);
                } else {
                    macdLine.push(ema12[i] - ema26[i]);
                }
            }
            
            // Calculate Signal Line (from valid MACD values)
            const validMacdValues = macdLine.filter(v => v !== null);
            const signalLine = calculateEMA(validMacdValues, signalLength);
            
            // Pad signal line with nulls to match macdLine length
            const paddedSignalLine = Array(macdLine.length - signalLine.length).fill(null).concat(signalLine);
            
            // Calculate Histogram
            const histogram = macdLine.map((value, i) => {
                if (value === null || paddedSignalLine[i] === null) {
                    return null;
                }
                return value - paddedSignalLine[i];
            });
            
            return {
                macdLine,
                signalLine: paddedSignalLine,
                histogram
            };
        }

        /**
         * Calculate EMA (Exponential Moving Average)
         */
        function calculateEMA(prices, period) {
            const k = 2 / (period + 1);
            const ema = [];
            
            // Initialize EMA with SMA
            let sum = 0;
            for (let i = 0; i < period && i < prices.length; i++) {
                if (i < period - 1) {
                    ema.push(null);
                }
                sum += prices[i];
            }
            
            // First EMA uses SMA as previous value
            ema.push(sum / period);
            
            // Calculate EMA
            for (let i = period; i < prices.length; i++) {
                ema.push(prices[i] * k + ema[ema.length - 1] * (1 - k));
            }
            
            return ema;
        }

        /**
         * Calculate Bollinger Bands
         */
        function calculateBollingerBands(prices, period = 20, multiplier = 2) {
            const middle = [];
            const upper = [];
            const lower = [];
            
            // Calculate simple moving average
            for (let i = 0; i < prices.length; i++) {
                if (i < period - 1) {
                    middle.push(null);
                    upper.push(null);
                    lower.push(null);
                } else {
                    // Calculate SMA
                    let sum = 0;
                    for (let j = i - period + 1; j <= i; j++) {
                        sum += prices[j];
                    }
                    const sma = sum / period;
                    
                    // Calculate standard deviation
                    let sumSquareDiff = 0;
                    for (let j = i - period + 1; j <= i; j++) {
                        sumSquareDiff += Math.pow(prices[j] - sma, 2);
                    }
                    const std = Math.sqrt(sumSquareDiff / period);
                    
                    middle.push(sma);
                    upper.push(sma + multiplier * std);
                    lower.push(sma - multiplier * std);
                }
            }
            
            return { middle, upper, lower };
        }

        /**
         * Check if the trend is confirmed
         */
        function checkTrendConfirmation(prices) {
            // Use a simple moving average cross system for trend confirmation
            const sma8 = calculateSMA(prices, 8);
            const sma21 = calculateSMA(prices, 21);
            
            // Check if 8-day MA is above 21-day MA (uptrend)
            const isUptrend = sma8[sma8.length - 1] > sma21[sma21.length - 1];
            
            // Check if 8-day MA crossed above 21-day MA recently (last 3 days)
            let recentCrossUp = false;
            for (let i = 2; i >= 0; i--) {
                const idx = sma8.length - 1 - i;
                if (idx > 0) {
                    const prev8 = sma8[idx - 1];
                    const prev21 = sma21[idx - 1];
                    const curr8 = sma8[idx];
                    const curr21 = sma21[idx];
                    
                    if (prev8 <= prev21 && curr8 > curr21) {
                        recentCrossUp = true;
                        break;
                    }
                }
            }
            
            return isUptrend || recentCrossUp;
        }

        /**
         * Calculate SMA (Simple Moving Average)
         */
        function calculateSMA(prices, period) {
            const sma = [];
            
            // Fill with nulls for the first (period-1) days
            for (let i = 0; i < period - 1 && i < prices.length; i++) {
                sma.push(null);
            }
            
            // Calculate SMA
            for (let i = period - 1; i < prices.length; i++) {
                let sum = 0;
                for (let j = i - period + 1; j <= i; j++) {
                    sum += prices[j];
                }
                sma.push(sum / period);
            }
            
            return sma;
        }

        /**
         * Fetch VIX value (market volatility index)
         */
        async function fetchVIX() {
            try {
                // In a real implementation, this would fetch actual VIX data
                // For demo purposes, simulate VIX with a random value
                return Math.random() * 20 + 15; // Random between 15-35
            } catch (error) {
                console.error('Error fetching VIX:', error);
                return 20; // Default to moderate volatility
            }
        }

        /**
         * Check if today is a trend day
         */
        async function checkTrendDay() {
            try {
                // In a real implementation, this would analyze market data
                // For demo purposes, randomly determine if it's a trend day
                return Math.random() > 0.7;
            } catch (error) {
                console.error('Error checking trend day:', error);
                return false;
            }
        }

        /**
         * Show notification popup
         */
        function showNotification(title, message, type = 'info') {
            const notificationId = 'notification-' + Date.now();
            
            // Create notification element
            const notification = document.createElement('div');
            notification.id = notificationId;
            notification.className = `trade-notification ${type}`;
            
            // Add notification content
            notification.innerHTML = `
                <div class="notification-header">
                    <strong>${title}</strong>
                    <span class="close-notification">&times;</span>
                </div>
                <div class="notification-body">
                    ${message}
                </div>
            `;
            
            // Add to document
            document.body.appendChild(notification);
            
            // Add close event
            notification.querySelector('.close-notification').addEventListener('click', () => {
                notification.remove();
            });
            
            // Auto remove after 5 seconds
            setTimeout(() => {
                if (document.getElementById(notificationId)) {
                    document.getElementById(notificationId).remove();
                }
            }, 5000);
        }

        // Initialize data from localStorage or create empty arrays
        let trades = JSON.parse(localStorage.getItem('trades')) || [];
        // Use var instead of let to avoid duplicate declaration errors
        var watchlist = JSON.parse(localStorage.getItem('watchlist')) || ['NIO', 'PLTR', 'RIVN', 'FUBO', 'MARA'];
        let currentEditId = null;
        let priceUpdateInterval;
        let tradingViewWidget = null;
        let alpacaClient = null;
        let alpacaConnected = false;
        let alpacaMode = localStorage.getItem('alpacaMode') || 'paper'; // 'paper' or 'live'
        let darkMode = localStorage.getItem('darkMode') === 'true';
        let currentStrategy = 'swing'; // 'swing' or 'scalp'
        let marketStatusInterval;
        let equityChart = null;
        
        // Initialize AutoTrader and TradeLogger
        let autoTrader = new AutoTrader();
        let tradeLogger = new TradeLogger();
        let signalCheckInterval = null; // Will hold interval for checking signals
        let autoTradingActive = false;
        
        // API Keys storage
        const API_KEYS = {
            paper: {
                keyId: localStorage.getItem('alpacaPaperKey') || '',
                secretKey: localStorage.getItem('alpacaPaperSecret') || ''
            },
            live: {
                keyId: localStorage.getItem('alpacaLiveKey') || '',
                secretKey: localStorage.getItem('alpacaLiveSecret') || ''
            }
        };

        // Strategy configuration
        const swingStocks = ['PLTR', 'TSLA', 'NIO', 'RIVN', 'FUBO', 'MARA', 'AMD', 'SOFI', 'HOOD', 'LCID'];
        const scalpStocks = ['TSLA', 'AAPL', 'NVDA', 'COIN', 'SPY', 'QQQ', 'META', 'AMZN', 'GOOGL', 'MSFT'];
        
        let indicatorSettings = {
            swing: {
                rsiThreshold: 40,
                macdFast: 12,
                macdSlow: 26,
                macdSignal: 9,
                volumeSpikeMultiplier: 2.5,
                emaShort: 9,
                emaLong: 21,
                vwapBand: 0.5 // %
            },
            scalp: {
                rsiThreshold: 30,
                macdFast: 5,
                macdSlow: 13,
                macdSignal: 1,
                volumeSpikeMultiplier: 3.0,
                emaShort: 5,
                emaLong: 13,
                vwapBand: 0.3 // %
            }
        };

        // Market hours configuration (in Eastern Time)
        const marketHours = {
            regular: {
                open: { hour: 9, minute: 30 },
                close: { hour: 16, minute: 0 }
            },
            pre: {
                open: { hour: 4, minute: 0 },
                close: { hour: 9, minute: 30 }
            },
            post: {
                open: { hour: 16, minute: 0 },
                close: { hour: 20, minute: 0 }
            }
        };

        // DOM elements
        const activeTradesTable = document.getElementById('active-trades').querySelector('tbody');
        const tradeHistoryTable = document.getElementById('trade-history').querySelector('tbody');
        const winnersBody = document.getElementById('winners-body');
        const losersBody = document.getElementById('losers-body');
        const addTradeBtn = document.getElementById('add-trade-btn');
        const tradeForm = document.getElementById('trade-form');
        const tradeDataForm = document.getElementById('trade-data-form');
        const cancelTradeBtn = document.getElementById('cancel-trade-btn');
        const newWatchlistItem = document.getElementById('new-watchlist-item');
        const addToWatchlistBtn = document.getElementById('add-to-watchlist');
        const watchlistItems = document.getElementById('watchlist-items');
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        const exportCsvBtn = document.getElementById('export-csv');
        const importCsvBtn = document.getElementById('import-csv');
        const csvFileInput = document.getElementById('csv-file');
        const connectAlpacaBtn = document.getElementById('connect-alpaca');
        const refreshPortfolioBtn = document.getElementById('refresh-portfolio');
        const alpacaStatusEl = document.getElementById('alpaca-status');
        const alpacaModeEl = document.getElementById('alpaca-mode');
        const aiSignalsEl = document.getElementById('ai-signals');
        const darkModeToggle = document.getElementById('dark-mode-toggle');
        const lightModeToggle = document.getElementById('light-mode-toggle');
        const paperModeToggle = document.getElementById('paper-mode-toggle');
        const liveModeToggle = document.getElementById('live-mode-toggle');
        const marketStatusIndicator = document.getElementById('market-status-indicator');
        const marketStatusText = document.getElementById('market-status-text');
        const marketHoursInfo = document.getElementById('market-hours-info');
        const marketTimer = document.getElementById('market-timer');
        const totalTradesEl = document.getElementById('total-trades');
        const winRateEl = document.getElementById('win-rate');
        const avgGainEl = document.getElementById('avg-gain');
        const avgLossEl = document.getElementById('avg-loss');
        const riskRewardEl = document.getElementById('risk-reward');
        const profitFactorEl = document.getElementById('profit-factor');
        const currentStrategyDisplay = document.getElementById('current-strategy-display');
        const currentTimeframe = document.getElementById('current-timeframe');
        const currentTarget = document.getElementById('current-target');
        const currentStop = document.getElementById('current-stop');
        const currentIndicators = document.getElementById('current-indicators');
        const currentCandidates = document.getElementById('current-candidates');
        const currentLookfor = document.getElementById('current-lookfor');
        const portfolioSummary = document.getElementById('portfolio-summary');
        const portfolioContent = document.getElementById('portfolio-content');
        const portfolioModeDisplay = document.getElementById('portfolio-mode-display');
        let alpacaModal = document.getElementById('alpaca-modal'); // Changed to let so it can be reassigned
        const closeModalBtn = document.querySelector('.close-modal');
        const modalTabs = document.querySelectorAll('.modal-tab');
        const modalTabContents = document.querySelectorAll('.modal-tab-content');
        const strategyInfoToggle = document.getElementById('strategy-info-toggle');
        const strategyInfoContent = document.getElementById('strategy-info-content');
        const resizeChartBtn = document.getElementById('resize-chart-btn');
        const fullscreenChartBtn = document.getElementById('fullscreen-chart-btn');
        const tradingViewChartEl = document.getElementById('tradingview-chart');

        // Initialize the dashboard
        function initDashboard() {
            // Set initial theme
            updateTheme();
            
            // Set initial Alpaca mode
            updateAlpacaModeUI();
            
            // Initialize auto-trading UI with current Alpaca connection status
            updateAutoTradingUI();
            
            // Collapse strategy info by default to save space
            const strategyInfoToggle = document.getElementById('strategy-info-toggle');
            const strategyInfoContent = document.getElementById('strategy-info-content');
            if (strategyInfoToggle && strategyInfoContent) {
                strategyInfoToggle.classList.add('collapsed');
                strategyInfoContent.classList.add('collapsed');
                const toggleIndicator = strategyInfoToggle.querySelector('span:last-child');
                if (toggleIndicator) {
                    toggleIndicator.textContent = '▶';
                }
            }
            
            // Initialize all components
            renderActiveTrades();
            renderTradeHistory();
            renderWatchlist();
            updateStats();
            initTradingView();
            startPriceUpdates();
            generateAISignals();
            updateMarketStatus();
            startMarketStatusUpdates();
            setupStrategySwitcher();
            
            // Update auto-trading status from localStorage if it was previously enabled
            const wasAutoTradingEnabled = localStorage.getItem('autoTradingEnabled') === 'true';
            if (wasAutoTradingEnabled && alpacaConnected) {
                const autoTradingToggle = document.getElementById('auto-trading-toggle');
                const autoTradingPanel = document.getElementById('auto-trading-panel');
                if (autoTradingToggle) {
                    autoTradingToggle.checked = true;
                    autoTrader.enabled = true;
                    
                    const autoTradingStatus = document.getElementById('auto-trading-status');
                    if (autoTradingStatus) {
                        autoTradingStatus.textContent = 'Enabled';
                        autoTradingStatus.className = 'alpaca-connected';
                    }
                    
                    // Apply animation class
                    document.body.classList.add('auto-trading-active');
                    if (autoTradingPanel) {
                        autoTradingPanel.classList.add('auto-trading-active');
                    }
                }
            }
            
            // Set up event listeners
            setupEventListeners();
            
            // Check if Alpaca credentials exist and try to connect
            const tryAutoConnect = () => {
                const mode = localStorage.getItem('alpacaMode') || 'paper';
                if (mode === 'paper' && API_KEYS.paper.keyId && API_KEYS.paper.secretKey) {
                    connectAlpaca('paper', API_KEYS.paper.keyId, API_KEYS.paper.secretKey);
                } else if (mode === 'live' && API_KEYS.live.keyId && API_KEYS.live.secretKey) {
                    connectAlpaca('live', API_KEYS.live.keyId, API_KEYS.live.secretKey);
                }
            };
            
            // Initialize automation controls - do this last after everything else is set up
            setTimeout(function() {
                console.log("Initializing automation controls...");
                try {
                    tryAutoConnect();
                    initAutomationControls();
                } catch (e) {
                    console.error("Error initializing automation controls:", e);
                }
            }, 1000);
        }

        // Initialize automation controls
        function initAutomationControls() {
            const autoTradingToggle = document.getElementById('auto-trading-toggle');
            const autoTradingStatus = document.getElementById('auto-trading-status');
            const pauseAutoTrading = document.getElementById('pause-auto-trading');
            const viewAutoTrades = document.getElementById('view-auto-trades');
            const maxRisk = document.getElementById('max-risk');
            const maxTrades = document.getElementById('max-trades');
            const minConfidence = document.getElementById('min-confidence');
            const trailPercent = document.getElementById('trail-percent');
            const trailPercentValue = document.getElementById('trail-percent-value');
            const autoTradeHistoryModal = document.getElementById('auto-trade-history-modal');
            const closeModal = document.querySelector('.close-modal');
            
            // Load saved settings
            if (localStorage.getItem('autoTradingEnabled') === 'true') {
                autoTradingToggle.checked = true;
                autoTrader.enabled = true;
            } else {
                autoTradingToggle.checked = false;
                autoTrader.enabled = false;
            }
            
            // Initialize the enhanced UI
            updateAutoTradingUI();
            
            // Set risk settings from local storage or defaults
            if (autoTrader.settings) {
                maxRisk.value = autoTrader.settings.maxRiskPerTrade * 100;
                maxTrades.value = autoTrader.settings.maxDailyTrades;
                minConfidence.value = autoTrader.settings.minConfidence;
                
                // Update display values
                document.getElementById('max-risk-value').textContent = maxRisk.value + '%';
                document.getElementById('max-trades-value').textContent = maxTrades.value;
            }
            
            // Update auto-trade stats
            updateAutoTradeStats();
            
            // Set up event listeners for automation controls
            autoTradingToggle.addEventListener('change', function() {
                // Check if Alpaca is connected before enabling auto-trading
                if (this.checked && !alpacaConnected) {
                    alert("Please connect to Alpaca first before enabling auto-trading.");
                    this.checked = false;
                    return;
                }
                
                const autoTradingPanel = document.getElementById('auto-trading-panel');
                
                autoTrader.enabled = this.checked;
                localStorage.setItem('autoTradingEnabled', this.checked);
                
                // Update the enhanced UI
                updateAutoTradingUI();
                
                // Apply animation class to the panel
                if (this.checked) {
                    document.body.classList.add('auto-trading-active');
                    if (autoTradingPanel) {
                        autoTradingPanel.classList.add('auto-trading-active');
                        
                        // Play startup animation
                        const startupAnimation = [
                            { transform: 'translateY(5px)', opacity: 0.7 },
                            { transform: 'translateY(-5px)', opacity: 0.9 },
                            { transform: 'translateY(0)', opacity: 1 }
                        ];
                        
                        const timing = {
                            duration: 600,
                            iterations: 1,
                            easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)'
                        };
                        
                        autoTradingPanel.animate(startupAnimation, timing);
                    }
                } else {
                    document.body.classList.remove('auto-trading-active');
                    if (autoTradingPanel) {
                        autoTradingPanel.classList.remove('auto-trading-active');
                    }
                }
                
                // Show a notification
                showNotification(
                    this.checked ? 'Auto-trading enabled' : 'Auto-trading disabled', 
                    this.checked ? 'success' : 'warning'
                );
            });
            
            // Risk parameter change handlers
            maxRisk.addEventListener('change', function() {
                autoTrader.settings.maxRiskPerTrade = parseFloat(this.value) / 100;
                autoTrader.saveSettings();
            });
            
            maxTrades.addEventListener('change', function() {
                autoTrader.settings.maxDailyTrades = parseInt(this.value);
                autoTrader.saveSettings();
            });
            
            minConfidence.addEventListener('change', function() {
                autoTrader.settings.minConfidence = parseFloat(this.value);
                autoTrader.saveSettings();
            });
            
            // Pause auto-trading button
            pauseAutoTrading.addEventListener('click', function() {
                autoTradingPaused = !autoTradingPaused;
                
                if (!autoTradingPaused) {
                    // Resume auto-trading
                    autoTrader.enabled = autoTradingToggle.checked;
                    showNotification('Auto-trading resumed', 'success');
                } else {
                    // Pause auto-trading
                    autoTrader.enabled = false;
                    showNotification('Auto-trading paused', 'warning');
                }
                
                // Update the enhanced UI
                updateAutoTradingUI();
            });
            
            // View auto-trades modal
            viewAutoTrades.addEventListener('click', function() {
                autoTradeHistoryModal.style.display = 'block';
                renderAutoTradeHistory();
                console.log('Opening auto trade history modal');
            });
            
            // Close modal
            if (closeModal) {
                closeModal.addEventListener('click', function() {
                    autoTradeHistoryModal.style.display = 'none';
                });
            }
            
            // Also handle the close button at the bottom of the modal
            const closeAutoTradeHistory = document.getElementById('close-auto-trade-history');
            if (closeAutoTradeHistory) {
                closeAutoTradeHistory.addEventListener('click', function() {
                    autoTradeHistoryModal.style.display = 'none';
                });
            }
            
            // Close modal when clicking outside of it
            window.addEventListener('click', function(event) {
                if (event.target === autoTradeHistoryModal) {
                    autoTradeHistoryModal.style.display = 'none';
                }
            });
            
            // Start the periodic signal check
            startPeriodicSignalCheck();
        }
        
        // Function to show notifications
        function showNotification(title, message = '', type = 'info') {
            // Support both single message or title+message format
            if (arguments.length === 1 || (arguments.length === 2 && typeof arguments[1] === 'string' && ['success', 'info', 'warning', 'error'].includes(arguments[1]))) {
                message = title;
                title = '';
            }
            
            const container = document.querySelector('.toast-container') || createToastContainer();
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.innerHTML = `
                <div class="toast-message">${message}</div>
                <button class="toast-close">&times;</button>
            `;
            
            container.appendChild(toast);
            
            // Add event listener to close button
            toast.querySelector('.toast-close').addEventListener('click', function() {
                container.removeChild(toast);
            });
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (container.contains(toast)) {
                    container.removeChild(toast);
                }
            }, 5000);
        }
        
        // Helper function to create toast container
        function createToastContainer() {
            const container = document.createElement('div');
            container.className = 'toast-container';
            document.body.appendChild(container);
            return container;
        }
        
        // Update automation statistics
        function updateAutoTradeStats() {
            const todayTradesCount = document.getElementById('today-trades-count');
            const autoTradeSuccess = document.getElementById('auto-trade-success');
            const autoPL = document.getElementById('auto-trade-pl');
            const activeAutoTradesEl = document.getElementById('active-auto-trades');
            
            // Update today's trades counter
            todayTradesCount.textContent = autoTrader.dailyTrades || 0;
            
            // Initialize active trades display
            if (activeAutoTradesEl) {
                activeAutoTradesEl.textContent = activeAutoTrades || 0;
            }
            
            // Calculate success rate and average P/L from trade history
            const autoTrades = tradeLogger.getTrades().filter(trade => trade.isAutoTrade);
            
            if (autoTrades.length > 0) {
                const successfulTrades = autoTrades.filter(trade => trade.percentReturn > 0);
                const successRate = (successfulTrades.length / autoTrades.length) * 100;
                autoTradeSuccess.textContent = `${successRate.toFixed(1)}%`;
                
                // Calculate average P/L
                const totalPL = autoTrades.reduce((sum, trade) => sum + trade.percentReturn, 0);
                const avgPL = totalPL / autoTrades.length;
                autoPL.textContent = `${avgPL.toFixed(2)}%`;
                autoPL.className = avgPL >= 0 ? 'positive' : 'negative';
            } else {
                autoTradeSuccess.textContent = '0%';
                autoPL.textContent = '0%';
            }
        }
        
        // Render auto trade history in the modal
        function renderAutoTradeHistory() {
            const container = document.getElementById('auto-trade-history-content');
            const autoTrades = tradeLogger.getTrades().filter(trade => trade.isAutoTrade);
            
            if (autoTrades.length === 0) {
                container.innerHTML = '<div class="no-trades-message">No automated trades yet</div>';
                return;
            }
            
            // Sort trades by date (newest first)
            autoTrades.sort((a, b) => new Date(b.date) - new Date(a.date));
            
            container.innerHTML = '';
            
            autoTrades.forEach(trade => {
                const tradeEl = document.createElement('div');
                tradeEl.className = `trade-history-item ${trade.type.toLowerCase()}`;
                
                const result = trade.percentReturn >= 0 ? 'positive' : 'negative';
                const confidenceClass = trade.confidence >= 0.85 ? 'high-confidence' : 
                                       (trade.confidence >= 0.75 ? 'medium-confidence' : 'low-confidence');
                
                tradeEl.innerHTML = `
                    <div>
                        <strong>${trade.symbol}</strong>
                        <div class="trade-date">${new Date(trade.date).toLocaleDateString()}</div>
                    </div>
                    <div>${trade.type}</div>
                    <div>$${trade.price.toFixed(2)}</div>
                    <div>${trade.quantity}</div>
                    <div>
                        <span class="confidence-indicator ${confidenceClass}"></span>
                        ${(trade.confidence * 100).toFixed(0)}%
                    </div>
                    <div class="${result}">
                        ${trade.percentReturn > 0 ? '+' : ''}${trade.percentReturn.toFixed(2)}%
                    </div>
                `;
                
                container.appendChild(tradeEl);
            });
        }
        
        // Start periodic signal check for auto-trading
        function startPeriodicSignalCheck() {
            setInterval(() => {
                if (autoTrader.enabled && alpacaConnected) {
                    checkForTradingSignals();
                }
            }, 60000); // Check every minute
        }
        
        // Check for trading signals and execute auto-trades
        function checkForTradingSignals() {
            const signals = generateAISignals(); // Get fresh signals
            
            if (!signals || signals.length === 0) return;
            
            signals.forEach(signal => {
                if (signal.confidenceScore >= autoTrader.settings.minConfidence) {
                    if (autoTrader.canPlaceTrade(signal.confidenceScore)) {
                        // Execute auto-trade
                        executeAutoTrade(signal);
                    }
                }
            });
        }
        
        // Execute an automated trade
        function executeAutoTrade(signal) {
            // Implement the trade execution
            if (!alpacaConnected || !autoTrader.enabled) return;
            
            const quantity = autoTrader.calculatePositionSize(
                signal.symbol, 
                signal.price, 
                signal.stopPrice, 
                accountValue
            );
            
            if (quantity <= 0) {
                console.error('Invalid position size calculated');
                return;
            }
            
            // Create order object
            const order = {
                symbol: signal.symbol,
                qty: quantity,
                side: signal.action === 'BUY' ? 'buy' : 'sell',
                type: 'market',
                time_in_force: 'day'
            };
            
            // Execute the trade via Alpaca
            submitAlpacaOrder(order)
                .then(response => {
                    if (response.id) {
                        // Trade successful
                        autoTrader.dailyTrades++;
                        autoTrader.lastTradeTime = new Date();
                        
                        // Log the trade
                        const trade = {
                            id: response.id,
                            symbol: signal.symbol,
                            type: signal.action,
                            price: signal.price,
                            quantity: quantity,
                            date: new Date().toISOString(),
                            isAutoTrade: true,
                            confidence: signal.confidenceScore,
                            percentReturn: 0, // Will be updated on close
                            status: 'open'
                        };
                        
                        tradeLogger.logTrade(trade);
                        updateAutoTradeStats();
                        showNotification(`Auto-trade: ${signal.action} ${signal.symbol}`, 'success');
                        
                        // Set up trailing stop if enabled
                        if (autoTrader.settings.useTrailingStops) {
                            autoTrader.setTrailingStop(signal.symbol, signal.price, signal.action);
                        }
                    }
                })
                .catch(error => {
                    console.error('Auto-trade failed:', error);
                    showNotification('Auto-trade failed: ' + error.message, 'error');
                });
        }

        // Set up all event listeners
        function setupEventListeners() {
            // Theme toggles
            darkModeToggle.addEventListener('click', () => setDarkMode(true));
            lightModeToggle.addEventListener('click', () => setDarkMode(false));
            
            // Alpaca mode toggles
            paperModeToggle.addEventListener('click', () => setAlpacaMode('paper'));
            liveModeToggle.addEventListener('click', () => setAlpacaMode('live'));
            
            // Trade form
            addTradeBtn.addEventListener('click', () => {
                currentEditId = null;
                tradeDataForm.reset();
                tradeForm.style.display = 'block';
                addTradeBtn.style.display = 'none';
            });

            cancelTradeBtn.addEventListener('click', () => {
                tradeForm.style.display = 'none';
                addTradeBtn.style.display = 'block';
            });

            // Watchlist
            addToWatchlistBtn.addEventListener('click', addToWatchlist);
            newWatchlistItem.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addToWatchlist();
            });

            // Trade form submission
            tradeDataForm.addEventListener('submit', (e) => {
                e.preventDefault();
                saveTrade();
            });

            // CSV export/import
            exportCsvBtn.addEventListener('click', exportToCSV);
            importCsvBtn.addEventListener('click', () => csvFileInput.click());
            csvFileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) importFromCSV(e.target.files[0]);
            });
            
            // Alpaca connection
            connectAlpacaBtn.addEventListener('click', showAlpacaModal);
            refreshPortfolioBtn.addEventListener('click', loadAlpacaPortfolio);
            
            // Tabs
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('active'));
                    tabContents.forEach(c => c.classList.remove('active'));
                    
                    tab.classList.add('active');
                    document.getElementById(`${tab.dataset.tab}-trades`).classList.add('active');
                    
                    if (tab.dataset.tab === 'equity') {
                        renderEquityCurve();
                    }
                });
            });
            
            // Modal tabs
            modalTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    modalTabs.forEach(t => t.classList.remove('active'));
                    modalTabContents.forEach(c => c.classList.remove('active'));
                    
                    tab.classList.add('active');
                    document.getElementById(`${tab.dataset.tab}-tab`).classList.add('active');
                });
            });
            
            // Close alpaca modal
            document.querySelectorAll('.close-modal').forEach(btn => {
                btn.addEventListener('click', function() {
                    // Find the closest modal parent
                    const modal = this.closest('.modal-wrapper');
                    if (modal) {
                        modal.style.display = 'none';
                    }
                });
            });
            
            // Connect paper account
            document.getElementById('connect-paper').addEventListener('click', () => {
                const key = document.getElementById('paper-key').value.trim();
                const secret = document.getElementById('paper-secret').value.trim();
                
                if (key && secret) {
                    connectAlpaca('paper', key, secret);
                } else {
                    alert('Please enter both API Key and Secret for paper trading');
                }
            });
            
            // Connect live account
            document.getElementById('connect-live').addEventListener('click', () => {
                const key = document.getElementById('live-key').value.trim();
                const secret = document.getElementById('live-secret').value.trim();
                
                if (key && secret) {
                    connectAlpaca('live', key, secret);
                } else {
                    alert('Please enter both API Key and Secret for live trading');
                }
            });
            
            // Click outside modal to close
            window.addEventListener('click', (e) => {
                if (e.target === alpacaModal) {
                    alpacaModal.style.display = 'none';
                }
            });
            
            // Strategy info toggle - updated to use collapse/expand animation
            strategyInfoToggle.addEventListener('click', () => {
                strategyInfoToggle.classList.toggle('collapsed');
                strategyInfoContent.classList.toggle('collapsed');
                
                // Update the toggle indicator
                const toggleIndicator = strategyInfoToggle.querySelector('span:last-child');
                if (toggleIndicator) {
                    if (strategyInfoContent.classList.contains('collapsed')) {
                        toggleIndicator.textContent = '▶';
                    } else {
                        toggleIndicator.textContent = '▼';
                    }
                }
            });
            
            // Chart controls
            resizeChartBtn.addEventListener('click', toggleChartSize);
            fullscreenChartBtn.addEventListener('click', toggleFullscreenChart);
        }

        // Toggle chart size between small and medium
        function toggleChartSize() {
            if (tradingViewChartEl.style.height === '600px') {
                tradingViewChartEl.style.height = '300px';
                resizeChartBtn.textContent = 'Enlarge Chart';
            } else {
                tradingViewChartEl.style.height = '600px';
                resizeChartBtn.textContent = 'Shrink Chart';
            }
            
            // Reinitialize TradingView widget
            if (tradingViewWidget) {
                const symbol = document.querySelector('.update-price')?.dataset?.symbol || 'PLTR';
                loadTradingViewChart(symbol);
            }
        }

        // Toggle fullscreen chart
        function toggleFullscreenChart() {
            if (!document.fullscreenElement) {
                const symbol = document.querySelector('.update-price')?.dataset?.symbol || 'PLTR';
                const fullscreenHTML = `
                    <div class="fullscreen-container">
                        <div class="fullscreen-chart" id="fullscreen-chart"></div>
                        <div class="fullscreen-signals">
                            <h3>AI Signals</h3>
                            <div class="signals-container" id="fullscreen-signals"></div>
                        </div>
                    </div>
                `;
                
                const fullscreenDiv = document.createElement('div');
                fullscreenDiv.innerHTML = fullscreenHTML;
                document.body.appendChild(fullscreenDiv);
                
                // Load chart
                new TradingView.widget({
                    autosize: true,
                    symbol: symbol.includes('USDT') ? 'BINANCE:' + symbol : symbol,
                    interval: '60',
                    timezone: 'Etc/UTC',
                    theme: darkMode ? 'dark' : 'light',
                    style: '1',
                    locale: 'en',
                    toolbar_bg: darkMode ? '#1a1a1a' : '#f1f3f6',
                    enable_publishing: false,
                    container_id: 'fullscreen-chart',
                    width: '100%',
                    height: '100%'
                });
                
                // Copy signals to fullscreen view
                document.getElementById('fullscreen-signals').innerHTML = 
                    document.getElementById('signals-container').innerHTML;
                    
                // Add event listeners to fullscreen signal buttons
                document.querySelectorAll('#fullscreen-signals .quick-action-btn').forEach(btn => {
                    if (btn.classList.contains('buy-btn')) {
                        btn.addEventListener('click', (e) => {
                            quickBuy(e.target.dataset.symbol, e.target.dataset.price);
                        });
                    } else if (btn.classList.contains('sell-btn')) {
                        btn.addEventListener('click', (e) => {
                            quickSell(e.target.dataset.symbol, e.target.dataset.price);
                        });
                    } else {
                        btn.addEventListener('click', (e) => {
                            loadTradingViewChart(e.target.dataset.symbol);
                        });
                    }
                });
                
                // Exit fullscreen handler
                const exitBtn = document.createElement('button');
                exitBtn.textContent = 'Exit Fullscreen';
                exitBtn.style.position = 'fixed';
                exitBtn.style.top = '10px';
                exitBtn.style.right = '10px';
                exitBtn.style.zIndex = '1001';
                exitBtn.className = 'quick-action-btn';
                exitBtn.addEventListener('click', () => {
                    document.exitFullscreen();
                    document.body.removeChild(fullscreenDiv);
                });
                fullscreenDiv.appendChild(exitBtn);
                
                fullscreenDiv.requestFullscreen().catch(err => {
                    alert(`Error attempting to enable fullscreen: ${err.message}`);
                });
            } else {
                document.exitFullscreen();
            }
        }

        // Show Alpaca connection modal - making it globally accessible
        window.showAlpacaModal = function() {
            console.log('Showing Alpaca modal - function called');
            try {
                // First check if the modal exists, create it if not
                let modalExists = document.getElementById('alpaca-modal');
                console.log('Alpaca modal exists:', !!modalExists);
                if (!modalExists) {
                    console.log('Alpaca modal not found, attempting to create dynamically...');
                    
                    // Create the modal structure
                    const modalHtml = `
                    <div id="alpaca-modal" class="modal-wrapper">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h2>Connect to Alpaca</h2>
                                <span class="modal-close">&times;</span>
                            </div>
                            <div class="modal-tabs">
                                <div class="modal-tab active" data-tab="paper">Paper Trading</div>
                                <div class="modal-tab" data-tab="live">Live Trading</div>
                            </div>
                            <div class="modal-tab-content active" id="paper-tab">
                                <div class="form-group">
                                    <label for="paper-key">API Key ID</label>
                                    <input type="text" id="paper-key" placeholder="Enter your paper trading API key">
                                </div>
                                <div class="form-group">
                                    <label for="paper-secret">Secret Key</label>
                                    <input type="password" id="paper-secret" placeholder="Enter your paper trading secret key">
                                </div>
                                <button id="connect-paper" class="btn buy-btn" style="width: 100%;">Connect Paper Account</button>
                            </div>
                            <div class="modal-tab-content" id="live-tab">
                                <div class="form-group">
                                    <label for="live-key">API Key ID</label>
                                    <input type="text" id="live-key" placeholder="Enter your live trading API key">
                                </div>
                                <div class="form-group">
                                    <label for="live-secret">Secret Key</label>
                                    <input type="password" id="live-secret" placeholder="Enter your live trading secret key">
                                </div>
                                <div class="warning" style="margin-bottom: 15px; color: #e74c3c;">
                                    <strong>Warning:</strong> Live trading uses real money. Only proceed if you understand the risks.
                                </div>
                                <button id="connect-live" class="btn sell-btn" style="width: 100%;">Connect Live Account</button>
                            </div>
                        </div>
                    </div>`;
                    
                    // Append modal to the body
                    document.body.insertAdjacentHTML('beforeend', modalHtml);
                    
                    // Set up event listeners for the new modal
                    const newModal = document.getElementById('alpaca-modal');
                    
                    // Close button
                    const closeButton = newModal.querySelector('.modal-close');
                    if (closeButton) {
                        closeButton.addEventListener('click', function() {
                            newModal.style.display = 'none';
                        });
                    }
                    
                    // Click outside to close
                    window.addEventListener('click', function(e) {
                        if (e.target === newModal) {
                            newModal.style.display = 'none';
                        }
                    });
                    
                    // Connect buttons
                    const connectPaperBtn = document.getElementById('connect-paper');
                    if (connectPaperBtn) {
                        connectPaperBtn.addEventListener('click', function() {
                            const key = document.getElementById('paper-key').value.trim();
                            const secret = document.getElementById('paper-secret').value.trim();
                            if (key && secret) {
                                connectAlpaca('paper', key, secret);
                            } else {
                                alert('Please enter both API Key and Secret Key');
                            }
                        });
                    }
                    
                    const connectLiveBtn = document.getElementById('connect-live');
                    if (connectLiveBtn) {
                        connectLiveBtn.addEventListener('click', function() {
                            if (!confirm('WARNING: You are about to connect with LIVE trading using REAL money. Are you sure?')) {
                                return;
                            }
                            const key = document.getElementById('live-key').value.trim();
                            const secret = document.getElementById('live-secret').value.trim();
                            if (key && secret) {
                                connectAlpaca('live', key, secret);
                            } else {
                                alert('Please enter both API Key and Secret Key');
                            }
                        });
                    }
                    
                    // Update the global variable
                    alpacaModal = newModal;
                }
                
                // Make sure we have the latest reference to the modal
                alpacaModal = document.getElementById('alpaca-modal');
                
                // Pre-fill saved credentials if they exist
                if (document.getElementById('paper-key')) {
                    document.getElementById('paper-key').value = API_KEYS.paper.keyId || '';
                }
                if (document.getElementById('paper-secret')) {
                    document.getElementById('paper-secret').value = API_KEYS.paper.secretKey || '';
                }
                if (document.getElementById('live-key')) {
                    document.getElementById('live-key').value = API_KEYS.live.keyId || '';
                }
                if (document.getElementById('live-secret')) {
                    document.getElementById('live-secret').value = API_KEYS.live.secretKey || '';
                }
                
                // Setup modal tabs if not already set up
                setupModalTabs();
                
                // Finally, display the modal
                if (alpacaModal) {
                    alpacaModal.style.display = 'block';
                } else {
                    console.error('Failed to find or create alpaca modal');
                    alert('Error: Could not open Alpaca connection dialog. Please check the console for details.');
                }
            } catch (error) {
                console.error('Error showing Alpaca modal:', error);
                alert('Error showing Alpaca connection dialog. Please check the console for details.');
            }
        }
        
        // Set up modal tabs functionality
        function setupModalTabs() {
            try {
                // Check if we have modal tabs
                const modalTabs = document.querySelectorAll('.modal-tab');
                
                if (!modalTabs || modalTabs.length === 0) {
                    console.warn('No modal tabs found to setup');
                    return;
                }
                
                modalTabs.forEach(tab => {
                    try {
                        // Remove existing event listeners to prevent duplicates
                        const newTab = tab.cloneNode(true);
                        tab.parentNode.replaceChild(newTab, tab);
                        
                        // Add event listener to the new tab
                        newTab.addEventListener('click', () => {
                            try {
                                const allTabs = document.querySelectorAll('.modal-tab');
                                const allTabContents = document.querySelectorAll('.modal-tab-content');
                                
                                // Remove active class from all tabs and contents
                                allTabs.forEach(t => t.classList.remove('active'));
                                allTabContents.forEach(c => c.classList.remove('active'));
                                
                                // Add active class to selected tab and content
                                newTab.classList.add('active');
                                const tabContentId = `${newTab.getAttribute('data-tab')}-tab`;
                                const tabContent = document.getElementById(tabContentId);
                                
                                if (tabContent) {
                                    tabContent.classList.add('active');
                                } else {
                                    console.warn(`Tab content with id ${tabContentId} not found`);
                                }
                            } catch (tabClickError) {
                                console.error('Error in tab click handler:', tabClickError);
                            }
                        });
                    } catch (tabError) {
                        console.error('Error setting up individual tab:', tabError);
                    }
                });
                
                console.log('Modal tabs setup complete');
            } catch (error) {
                console.error('Error setting up modal tabs:', error);
            }
        }

        // Connect to Alpaca API
        // Make the function accessible globally for external scripts
        window.connectAlpaca = function(mode, key, secret) {
            try {
                // Initialize Alpaca with proper configuration
                const baseUrl = mode === 'paper' 
                    ? 'https://paper-api.alpaca.markets' 
                    : 'https://api.alpaca.markets';
                
                // Create client with our custom implementation
                alpacaClient = new AlpacaClient({
                    keyId: key,
                    secretKey: secret,
                    baseUrl: baseUrl,
                    paper: mode === 'paper',
                    apiVersion: 'v2'
                });
                
                // Test connection
                alpacaClient.getAccount().then(account => {
                    // Save credentials
                    if (mode === 'paper') {
                        localStorage.setItem('alpacaPaperKey', key);
                        localStorage.setItem('alpacaPaperSecret', secret);
                        API_KEYS.paper.keyId = key;
                        API_KEYS.paper.secretKey = secret;
                    } else {
                        localStorage.setItem('alpacaLiveKey', key);
                        localStorage.setItem('alpacaLiveSecret', secret);
                        API_KEYS.live.keyId = key;
                        API_KEYS.live.secretKey = secret;
                    }
                    
                    alpacaConnected = true;
                    alpacaMode = mode;
                    localStorage.setItem('alpacaMode', alpacaMode);
                    
                    // Update all Alpaca status indicators across the UI
                    alpacaStatusEl.textContent = "Connected";
                    alpacaStatusEl.className = mode === 'paper' ? "alpaca-paper" : "alpaca-connected";
                    
                    // Status indicator has been replaced with withdrawable cash display
                    
                    // Update other displays
                    alpacaModeEl.style.display = 'inline';
                    alpacaModeEl.textContent = mode === 'paper' ? 'Paper' : 'Live';
                    connectAlpacaBtn.textContent = "Alpaca Connected";
                    portfolioModeDisplay.textContent = mode === 'paper' ? 'Paper Trading' : 'Live Trading';
                    
                    // Update mode toggle UI
                    updateAlpacaModeUI();
                    
                    // Close modal
                    alpacaModal.style.display = 'none';
                    
                    // Load portfolio data
                    loadAlpacaPortfolio();
                    
                    // Update auto-trading UI since we're now connected
                    updateAutoTradingUI();
                    
                    alert(`Successfully connected to Alpaca ${mode} trading!\nAccount ID: ${account.id}\nBuying Power: $${account.buying_power}`);
                }).catch(err => {
                    console.error('Alpaca connection error:', err);
                    alpacaConnected = false;
                    alpacaStatusEl.textContent = "Disconnected";
                    alpacaStatusEl.className = "alpaca-disconnected";
                    alpacaModeEl.style.display = 'none';
                    portfolioModeDisplay.textContent = 'Not Connected';
                    
                    // Disable auto-trading if Alpaca connection fails
                    if (autoTrader) {
                        autoTrader.enabled = false;
                        const autoTradingToggle = document.getElementById('auto-trading-toggle');
                        const autoTradingStatus = document.getElementById('auto-trading-status');
                        if (autoTradingToggle) autoTradingToggle.checked = false;
                        if (autoTradingStatus) {
                            autoTradingStatus.textContent = 'Disabled';
                            autoTradingStatus.className = 'alpaca-disconnected';
                        }
                        localStorage.setItem('autoTradingEnabled', 'false');
                    }
                    
                    alert(`Failed to connect to Alpaca ${mode} trading: ${err.message}`);
                });
            } catch (e) {
                console.error('Alpaca initialization error:', e);
                alpacaConnected = false;
                alpacaStatusEl.textContent = "Disconnected";
                alpacaStatusEl.className = "alpaca-disconnected";
                alpacaModeEl.style.display = 'none';
                portfolioModeDisplay.textContent = 'Not Connected';
                alert(`Error initializing Alpaca ${mode} trading: ${e.message}`);
            }
        }

        // Reconnect to Alpaca with the specified mode
        function reconnectAlpaca(mode) {
            // Get appropriate credentials for the mode
            let key, secret;
            
            if (mode === 'paper') {
                key = API_KEYS.paper.keyId;
                secret = API_KEYS.paper.secretKey;
                
                if (!key || !secret) {
                    if (API_KEYS.live.keyId && API_KEYS.live.secretKey) {
                        // If user has no paper keys saved but has live keys, ask if they want to enter new paper keys
                        if (confirm("No paper trading credentials found. Would you like to enter paper trading API keys?")) {
                            document.getElementById('paper-key').value = '';
                            document.getElementById('paper-secret').value = '';
                            alpacaModal.style.display = 'block';
                            document.querySelector('.modal-tab[data-tab="paper"]').click();
                            return;
                        } else {
                            // User didn't want to enter new keys, switch back to live mode
                            alpacaMode = 'live';
                            localStorage.setItem('alpacaMode', 'live');
                            updateAlpacaModeUI();
                            return;
                        }
                    } else {
                        // No keys saved at all
                        alert("Please connect to Alpaca paper trading first!");
                        alpacaModal.style.display = 'block';
                        document.querySelector('.modal-tab[data-tab="paper"]').click();
                        return;
                    }
                }
            } else { // Live mode
                key = API_KEYS.live.keyId;
                secret = API_KEYS.live.secretKey;
                
                if (!key || !secret) {
                    if (API_KEYS.paper.keyId && API_KEYS.paper.secretKey) {
                        // If user has no live keys saved but has paper keys, ask if they want to enter new live keys
                        if (confirm("No live trading credentials found. Would you like to enter live trading API keys?")) {
                            document.getElementById('live-key').value = '';
                            document.getElementById('live-secret').value = '';
                            alpacaModal.style.display = 'block';
                            document.querySelector('.modal-tab[data-tab="live"]').click();
                            return;
                        } else {
                            // User didn't want to enter new keys, switch back to paper mode
                            alpacaMode = 'paper';
                            localStorage.setItem('alpacaMode', 'paper');
                            updateAlpacaModeUI();
                            return;
                        }
                    } else {
                        // No keys saved at all
                        alert("Please connect to Alpaca live trading first!");
                        alpacaModal.style.display = 'block';
                        document.querySelector('.modal-tab[data-tab="live"]').click();
                        return;
                    }
                }
            }
            
            // Actually reconnect using the stored credentials
            try {
                // Initialize Alpaca with proper configuration
                const baseUrl = mode === 'paper' 
                    ? 'https://paper-api.alpaca.markets' 
                    : 'https://api.alpaca.markets';
                
                // Create client with our custom implementation
                alpacaClient = new Alpaca({
                    keyId: key,
                    secretKey: secret,
                    baseUrl: baseUrl,
                    paper: mode === 'paper',
                    apiVersion: 'v2'
                });
                
                // Update UI to reflect the current mode
                alpacaStatusEl.textContent = "Connected";
                alpacaStatusEl.className = mode === 'paper' ? "alpaca-paper" : "alpaca-connected";
                alpacaModeEl.style.display = 'inline';
                alpacaModeEl.textContent = mode === 'paper' ? 'Paper' : 'Live';
                connectAlpacaBtn.textContent = "Alpaca Connected";
                portfolioModeDisplay.textContent = mode === 'paper' ? 'Paper Trading' : 'Live Trading';
                
                // Load portfolio data with the new connection
                loadAlpacaPortfolio();
                
                console.log(`Reconnected to Alpaca ${mode} trading`);
            } catch (e) {
                console.error('Alpaca reconnection error:', e);
                alert(`Error reconnecting to Alpaca ${mode} trading: ${e.message}`);
            }
        }

        // Theme management
        function setDarkMode(enabled) {
            darkMode = enabled;
            localStorage.setItem('darkMode', darkMode);
            updateTheme();
        }

        function updateTheme() {
            if (darkMode) {
                document.body.classList.add('dark-mode');
                darkModeToggle.classList.add('active-mode');
                lightModeToggle.classList.remove('active-mode');
            } else {
                document.body.classList.remove('dark-mode');
                lightModeToggle.classList.add('active-mode');
                darkModeToggle.classList.remove('active-mode');
            }
            
            // Update TradingView theme if it exists
            if (tradingViewWidget) {
                const symbol = document.querySelector('.update-price')?.dataset?.symbol || 'PLTR';
                loadTradingViewChart(symbol);
            }
        }

        // Alpaca mode management
        function setAlpacaMode(mode) {
            // Don't do anything if not connected
            if (!alpacaConnected) {
                alert("Please connect to Alpaca first!");
                return;
            }
            
            // Ask for confirmation when switching to live mode
            if (mode === 'live' && alpacaMode !== 'live') {
                if (!confirm("Are you sure you want to switch to LIVE trading? Real money will be at risk.")) {
                    return;
                }
            }
            
            // Store the new mode
            alpacaMode = mode;
            localStorage.setItem('alpacaMode', alpacaMode);
            
            // Update UI
            updateAlpacaModeUI();
            
            // Reconnect with the proper mode
            reconnectAlpaca(mode);
        }

        function updateAlpacaModeUI() {
            if (alpacaMode === 'paper') {
                paperModeToggle.classList.add('active-mode');
                liveModeToggle.classList.remove('active-mode');
                alpacaModeEl.className = 'alpaca-paper';
            } else {
                liveModeToggle.classList.add('active-mode');
                paperModeToggle.classList.remove('active-mode');
                alpacaModeEl.className = 'alpaca-connected';
            }
        }

        // Initialize TradingView widget
        function initTradingView() {
            // Create a wrapper for TradingView initialization
            const initTVWithFallback = () => {
                // Only proceed if TradingView is available and the container exists
                if (window.TradingView) {
                    try {
                        loadTradingViewChart('PLTR');
                        console.log('TradingView chart requested');
                        
                        // Check after a delay if the chart loaded successfully
                        setTimeout(() => {
                            const chartContainer = document.getElementById('tradingview-chart');
                            if (chartContainer && chartContainer.querySelector('iframe')) {
                                console.log('TradingView chart iframe detected');
                            } else if (chartContainer && !chartContainer.querySelector('.tv-fallback')) {
                                console.log('Chart container exists but no iframe detected, showing fallback');
                                showChartFallback(chartContainer, 'PLTR');
                            }
                        }, 5000); // Check after 5 seconds
                    } catch (err) {
                        console.log('TradingView initialization error (handled):', err.message);
                        const chartEl = document.getElementById('tradingview-chart');
                        if (chartEl) {
                            showChartFallback(chartEl, 'PLTR');
                        }
                    }
                } else {
                    // TradingView not loaded yet, retry in 200ms
                    setTimeout(initTVWithFallback, 200);
                }
            };
            
            // Helper to show fallback UI when chart fails to load
            const showChartFallback = (element, symbol) => {
                if (!element.querySelector('.tv-fallback')) {
                    element.innerHTML = `
                        <div class="tv-fallback" style="text-align:center; padding:50px 20px; border:1px dashed #ccc; border-radius:8px; margin:10px">
                            <h3>Interactive Chart Unavailable</h3>
                            <p>We're having trouble loading the interactive chart component.</p>
                            <p>Symbol: ${symbol}</p>
                            <button onclick="initTradingView()" style="padding:8px 16px; margin-top:15px; background:#3498db; color:white; border:none; border-radius:4px; cursor:pointer;">
                                Try Again
                            </button>
                        </div>
                    `;
                }
            };
            
            // Start the initialization
            initTVWithFallback();
        }

        // Load TradingView chart
        function loadTradingViewChart(symbol) {
            if (tradingViewWidget) {
                try {
                    tradingViewWidget.remove();
                } catch (e) {
                    console.log('TradingView removal error (handled):', e.message);
                }
            }
            
            // Clear the chart container to ensure a fresh start
            const chartContainer = document.getElementById('tradingview-chart');
            chartContainer.innerHTML = '';
            
            // Setup error handling for TradingView errors
            const originalConsoleError = console.error;
            console.error = function(message) {
                // Filter out TradingView widget errors from console
                if ((typeof message === 'string' && 
                   (message.includes('TradingView') || 
                    message.includes('tv-basicstudies') || 
                    message.includes('metainfo'))) ||
                   (message instanceof Error && message.toString().includes('Cannot read properties'))) {
                    return; // Suppress error
                }
                originalConsoleError.apply(console, arguments);
            };
            
            // Handle the TypeError "cannot read properties of undefined"
            window.addEventListener('unhandledrejection', function(event) {
                if (event.reason && (
                    (typeof event.reason.message === 'string' && 
                     event.reason.message.includes('Cannot read properties of undefined'))
                )) {
                    event.preventDefault(); // Prevent the error from showing in console
                }
            });
            
            // Use lightweight chart configuration
            const chartConfig = {
                autosize: true,
                symbol: symbol.includes('USDT') ? 'BINANCE:' + symbol : symbol,
                interval: '60',
                timezone: 'Etc/UTC',
                theme: darkMode ? 'dark' : 'light',
                style: '1',
                locale: 'en',
                toolbar_bg: darkMode ? '#1a1a1a' : '#f1f3f6',
                enable_publishing: false,
                hide_top_toolbar: false,
                hide_side_toolbar: false,
                allow_symbol_change: true,
                save_image: false,
                // Simplified features
                withdateranges: true,
                container_id: 'tradingview-chart',
                width: '100%',
                height: tradingViewChartEl.style.height || '400px',
                // Add error handling
                loading_screen: { backgroundColor: darkMode ? "#1a1a1a" : "#ffffff" },
                // Disable problematic features
                disabled_features: [
                    "use_localstorage_for_settings",
                    "header_widget_buttons",
                    "timeframes_toolbar",
                    "volume_force_overlay",
                    "create_volume_indicator_by_default",
                    "display_market_status",
                    "study_dialog_search_control"
                ]
            };
            
            try {
                tradingViewWidget = new TradingView.widget(chartConfig);
            } catch (e) {
                console.log('TradingView creation error (handled):', e.message);
                chartContainer.innerHTML = `
                    <div class="tv-fallback" style="text-align:center; padding:50px 20px;">
                        <h3>Chart temporarily unavailable</h3>
                        <p>We're experiencing some issues with the charting service</p>
                        <button onclick="loadTradingViewChart('${symbol}')" style="padding:8px 16px; margin-top:15px;">
                            Retry Loading Chart
                        </button>
                    </div>
                `;
            }
        }

        // Save trade from form
        function saveTrade() {
            const tradeData = {
                id: currentEditId || generateId(),
                symbol: document.getElementById('symbol').value.trim().toUpperCase(),
                direction: document.getElementById('direction').value,
                entryPrice: parseFloat(document.getElementById('entry-price').value),
                currentPrice: parseFloat(document.getElementById('current-price').value),
                positionSize: parseFloat(document.getElementById('position-size').value),
                stopLoss: document.getElementById('stop-loss').value ? parseFloat(document.getElementById('stop-loss').value) : null,
                takeProfit: document.getElementById('take-profit').value ? parseFloat(document.getElementById('take-profit').value) : null,
                chartLink: document.getElementById('chart-link').value.trim() || null,
                notes: document.getElementById('notes').value.trim() || null,
                entryDate: new Date().toISOString(),
                exitPrice: null,
                exitDate: null
            };
            
            if (currentEditId) {
                // Update existing trade
                const index = trades.findIndex(t => t.id === currentEditId);
                if (index !== -1) trades[index] = tradeData;
            } else {
                // Add new trade
                trades.push(tradeData);
            }
            
            saveTrades();
            tradeForm.style.display = 'none';
            addTradeBtn.style.display = 'block';
            renderActiveTrades();
            updateStats();
        }

        // Render active trades
        function renderActiveTrades() {
            activeTradesTable.innerHTML = '';
            
            const activeTrades = trades.filter(trade => !trade.exitPrice);
            
            if (activeTrades.length === 0) {
                activeTradesTable.innerHTML = '<tr><td colspan="7" style="text-align: center;">No active trades</td></tr>';
                return;
            }
            
            activeTrades.forEach(trade => {
                const plPercent = calculatePLPercent(trade.entryPrice, trade.currentPrice, trade.direction);
                const row = document.createElement('tr');
                
                row.innerHTML = `
                    <td>${trade.symbol}</td>
                    <td>${trade.entryPrice.toFixed(4)}</td>
                    <td><input type="number" value="${trade.currentPrice.toFixed(4)}" step="0.0001" data-trade-id="${trade.id}" class="update-price" style="width: 80px;"></td>
                    <td>$${trade.positionSize.toFixed(2)}</td>
                    <td class="${getPLClass(plPercent)}">${plPercent.toFixed(2)}%</td>
                    <td>${trade.chartLink ? `<a href="${trade.chartLink}" target="_blank" class="chart-link">View</a>` : '-'}</td>
                    <td>
                        <button class="quick-action-btn edit-trade" data-id="${trade.id}">Edit</button>
                        <button class="quick-action-btn sell-btn close-trade" data-id="${trade.id}">Close</button>
                        <button class="quick-action-btn chart-trade" data-symbol="${trade.symbol}">Chart</button>
                    </td>
                `;
                
                activeTradesTable.appendChild(row);
            });
            
            // Add event listeners for dynamic elements
            document.querySelectorAll('.update-price').forEach(input => {
                input.addEventListener('change', (e) => {
                    updateTradePrice(e.target.dataset.tradeId, parseFloat(e.target.value));
                });
            });
            
            document.querySelectorAll('.edit-trade').forEach(btn => {
                btn.addEventListener('click', (e) => editTrade(e.target.dataset.id));
            });
            
            document.querySelectorAll('.close-trade').forEach(btn => {
                btn.addEventListener('click', (e) => closeTrade(e.target.dataset.id));
            });
            
            document.querySelectorAll('.chart-trade').forEach(btn => {
                btn.addEventListener('click', (e) => loadTradingViewChart(e.target.dataset.symbol));
            });
        }

        // Edit trade
        function editTrade(tradeId) {
            const trade = trades.find(t => t.id === tradeId);
            if (trade) {
                currentEditId = tradeId;
                document.getElementById('symbol').value = trade.symbol;
                document.getElementById('direction').value = trade.direction;
                document.getElementById('entry-price').value = trade.entryPrice;
                document.getElementById('current-price').value = trade.currentPrice;
                document.getElementById('position-size').value = trade.positionSize;
                document.getElementById('stop-loss').value = trade.stopLoss || '';
                document.getElementById('take-profit').value = trade.takeProfit || '';
                document.getElementById('chart-link').value = trade.chartLink || '';
                document.getElementById('notes').value = trade.notes || '';
                
                tradeForm.style.display = 'block';
                addTradeBtn.style.display = 'none';
            }
        }

        // Close trade
        function closeTrade(tradeId) {
            const trade = trades.find(t => t.id === tradeId);
            if (trade) {
                const exitPrice = prompt(`Enter exit price for ${trade.symbol}:`, trade.currentPrice.toFixed(4));
                if (exitPrice && !isNaN(parseFloat(exitPrice))) {
                    const tradeIndex = trades.findIndex(t => t.id === tradeId);
                    if (tradeIndex !== -1) {
                        trades[tradeIndex].exitPrice = parseFloat(exitPrice);
                        trades[tradeIndex].exitDate = new Date().toISOString();
                        saveTrades();
                        renderActiveTrades();
                        renderTradeHistory();
                        updateStats();
                        
                        // Execute sell order through Alpaca if connected
                        if (alpacaConnected) {
                            executeAlpacaOrder(trade.symbol, 'sell', trade.positionSize);
                        }
                    }
                }
            }
        }

        // Update trade price
        function updateTradePrice(tradeId, newPrice) {
            const tradeIndex = trades.findIndex(t => t.id === tradeId);
            if (tradeIndex !== -1) {
                trades[tradeIndex].currentPrice = newPrice;
                saveTrades();
                renderActiveTrades();
            }
        }

        // Render trade history
        function renderTradeHistory() {
            tradeHistoryTable.innerHTML = '';
            winnersBody.innerHTML = '';
            losersBody.innerHTML = '';
            
            const closedTrades = trades.filter(trade => trade.exitPrice).reverse();
            
            if (closedTrades.length === 0) {
                tradeHistoryTable.innerHTML = '<tr><td colspan="8" style="text-align: center;">No trade history</td></tr>';
                winnersBody.innerHTML = '<tr><td colspan="8" style="text-align: center;">No winning trades</td></tr>';
                losersBody.innerHTML = '<tr><td colspan="8" style="text-align: center;">No losing trades</td></tr>';
                return;
            }
            
            closedTrades.forEach(trade => {
                const plPercent = calculatePLPercent(trade.entryPrice, trade.exitPrice, trade.direction);
                const plDollar = calculatePLDollar(trade.entryPrice, trade.exitPrice, trade.positionSize, trade.direction);
                const row = document.createElement('tr');
                const date = new Date(trade.exitDate).toLocaleDateString();
                
                row.innerHTML = `
                    <td>${trade.symbol}</td>
                    <td>${trade.direction}</td>
                    <td>${trade.entryPrice.toFixed(4)}</td>
                    <td>${trade.exitPrice.toFixed(4)}</td>
                    <td>$${trade.positionSize.toFixed(2)}</td>
                    <td class="${getPLClass(plPercent)}">${plPercent.toFixed(2)}%</td>
                    <td class="${getPLClass(plPercent)}">$${plDollar.toFixed(2)}</td>
                    <td>${date}</td>
                `;
                
                tradeHistoryTable.appendChild(row.cloneNode(true));
                
                if (plPercent >= 0) {
                    winnersBody.appendChild(row.cloneNode(true));
                } else {
                    losersBody.appendChild(row);
                }
            });
        }

        // Render watchlist
        function renderWatchlist() {
            watchlistItems.innerHTML = '';
            
            if (watchlist.length === 0) {
                watchlistItems.innerHTML = '<div class="neutral">Your watchlist is empty</div>';
                return;
            }
            
            watchlist.forEach((symbol, index) => {
                const item = document.createElement('div');
                item.className = 'watchlist-item';
                item.innerHTML = `
                    ${symbol}
                    <button data-index="${index}" class="remove-watchlist-item">×</button>
                    <button data-symbol="${symbol}" class="chart-watchlist-item" style="margin-left: 5px;">📊</button>
                    <button data-symbol="${symbol}" class="buy-watchlist-item buy-btn quick-action-btn" style="margin-left: 5px;">Buy</button>
                `;
                watchlistItems.appendChild(item);
            });
            
            // Add event listeners for watchlist items
            document.querySelectorAll('.remove-watchlist-item').forEach(btn => {
                btn.addEventListener('click', (e) => removeFromWatchlist(e.target.dataset.index));
            });
            
            document.querySelectorAll('.chart-watchlist-item').forEach(btn => {
                btn.addEventListener('click', (e) => loadTradingViewChart(e.target.dataset.symbol));
            });
            
            document.querySelectorAll('.buy-watchlist-item').forEach(btn => {
                btn.addEventListener('click', (e) => quickBuy(e.target.dataset.symbol));
            });
        }

        // Add to watchlist
        function addToWatchlist() {
            const symbol = newWatchlistItem.value.trim().toUpperCase();
            if (symbol && !watchlist.includes(symbol)) {
                watchlist.push(symbol);
                saveWatchlist();
                renderWatchlist();
                newWatchlistItem.value = '';
            }
        }

        // Remove from watchlist
        function removeFromWatchlist(index) {
            watchlist.splice(index, 1);
            saveWatchlist();
            renderWatchlist();
        }

        // Quick buy function
        function quickBuy(symbol, priceStr) {
            const amount = prompt(`Enter amount to invest in ${symbol} ($):`, "1000");
            if (amount && !isNaN(parseFloat(amount))) {
                let entryPriceNum;
                if (priceStr !== undefined) {
                    entryPriceNum = parseFloat(priceStr);
                } else {
                    entryPriceNum = getCurrentPrice(symbol);
                }
        
                if (entryPriceNum === undefined || isNaN(entryPriceNum)) {
                    entryPriceNum = parseFloat(prompt(`Enter entry price for ${symbol}:`));
                }
        
                if (entryPriceNum && !isNaN(entryPriceNum)) {
                    const stopLoss = currentStrategy === 'swing' 
                        ? entryPriceNum * 0.97 // 3% stop loss for swing
                        : entryPriceNum * 0.995; // 0.5% stop loss for scalp
                        
                    const takeProfit = currentStrategy === 'swing'
                        ? entryPriceNum * 1.08 // 8% take profit for swing
                        : entryPriceNum * 1.02; // 2% take profit for scalp
                    
                    const newTrade = {
                        id: generateId(),
                        symbol: symbol,
                        direction: 'Long',
                        entryPrice: entryPriceNum,
                        currentPrice: entryPriceNum,
                        positionSize: parseFloat(amount),
                        stopLoss: parseFloat(stopLoss.toFixed(4)),
                        takeProfit: parseFloat(takeProfit.toFixed(4)),
                        notes: `Quick buy from ${currentStrategy} signals`,
                        entryDate: new Date().toISOString(),
                        exitPrice: null,
                        exitDate: null,
                        chartLink: `https://www.tradingview.com/chart/?symbol=${symbol}`
                    };
                    
                    trades.push(newTrade);
                    saveTrades();
                    renderActiveTrades();
                    updateStats();
                    
                    // Execute buy order through Alpaca if connected
                    if (alpacaConnected) {
                        executeAlpacaOrder(symbol, 'buy', parseFloat(amount));
                    }
                } else {
                    alert("Invalid entry price.");
                }
            }
        }

        // Quick sell function
        function quickSell(symbol, priceStr) {
            const amount = prompt(`Enter amount to sell for ${symbol} ($):`, "1000");
            if (amount && !isNaN(parseFloat(amount))) {
                let entryPriceNum;
                if (priceStr !== undefined) {
                    entryPriceNum = parseFloat(priceStr);
                } else {
                    entryPriceNum = getCurrentPrice(symbol);
                }

                if (entryPriceNum === undefined || isNaN(entryPriceNum)) {
                    entryPriceNum = parseFloat(prompt(`Enter current price for ${symbol}:`));
                }

                if (entryPriceNum && !isNaN(entryPriceNum)) {
                    const newTrade = {
                        id: generateId(),
                        symbol: symbol,
                        direction: 'Short',
                        entryPrice: entryPriceNum,
                        currentPrice: entryPriceNum,
                        positionSize: parseFloat(amount),
                        notes: `Quick sell from ${currentStrategy} signals`,
                        entryDate: new Date().toISOString(),
                        exitPrice: null,
                        exitDate: null,
                        chartLink: `https://www.tradingview.com/chart/?symbol=${symbol}`
                    };
                    
                    trades.push(newTrade);
                    saveTrades();
                    renderActiveTrades();
                    updateStats();
                    
                    // Execute sell order through Alpaca if connected
                    if (alpacaConnected) {
                        executeAlpacaOrder(symbol, 'sell', parseFloat(amount));
                    }
                } else {
                    alert("Invalid entry price.");
                }
            }
        }

        // Load Alpaca portfolio
        function loadAlpacaPortfolio() {
            if (!alpacaConnected) {
                alert("Please connect to Alpaca first!");
                return;
            }
            
            portfolioContent.innerHTML = '<p>Loading portfolio data...</p>';
            
            Promise.all([
                alpacaClient.getAccount(),
                alpacaClient.getPositions()
            ]).then(([account, positions]) => {
                // Update the top stats section with portfolio data
                document.getElementById('alpaca-value').textContent = `$${parseFloat(account.portfolio_value).toFixed(2)}`;
                document.getElementById('alpaca-buying-power').textContent = `$${parseFloat(account.buying_power).toFixed(2)}`;
                document.getElementById('alpaca-cash').textContent = `$${parseFloat(account.cash).toFixed(2)}`;
                document.getElementById('alpaca-positions').textContent = positions.length;
                
                // Update cash withdrawable if available
                const withdrawableElement = document.getElementById('alpaca-withdrawable');
                if (account.withdrawable_cash) {
                    withdrawableElement.textContent = `$${parseFloat(account.withdrawable_cash).toFixed(2)}`;
                } else if (account.cash) {
                    // Fall back to cash if withdrawable_cash is not available
                    withdrawableElement.textContent = `$${parseFloat(account.cash).toFixed(2)}`;
                }
                
                // Calculate today's P/L from positions
                let todaysPL = 0;
                positions.forEach(position => {
                    todaysPL += parseFloat(position.unrealized_intraday_pl || 0);
                });
                
                const plElement = document.getElementById('alpaca-daily-pl');
                plElement.textContent = `$${todaysPL.toFixed(2)}`;
                plElement.classList.remove('positive', 'negative');
                plElement.classList.add(todaysPL >= 0 ? 'positive' : 'negative');
                
                // Update main portfolio display
                let html = `
                    <div class="portfolio-item">
                        <span class="portfolio-label">Buying Power:</span>
                        <span class="portfolio-value">$${parseFloat(account.buying_power).toFixed(2)}</span>
                    </div>
                    <div class="portfolio-item">
                        <span class="portfolio-label">Equity:</span>
                        <span class="portfolio-value">$${parseFloat(account.equity).toFixed(2)}</span>
                    </div>
                    <div class="portfolio-item">
                        <span class="portfolio-label">Cash:</span>
                        <span class="portfolio-value">$${parseFloat(account.cash).toFixed(2)}</span>
                    </div>
                    <div class="portfolio-item">
                        <span class="portfolio-label">Cash Withdrawable:</span>
                        <span class="portfolio-value">$${parseFloat(account.withdrawable_cash || account.cash).toFixed(2)}</span>
                    </div>
                    <div class="portfolio-item">
                        <span class="portfolio-label">Portfolio Value:</span>
                        <span class="portfolio-value">$${parseFloat(account.portfolio_value).toFixed(2)}</span>
                    </div>
                `;
                
                if (positions.length > 0) {
                    html += `<h4 style="margin-top: 15px;">Positions</h4>`;
                    
                    positions.forEach(position => {
                                               const marketValue = parseFloat(position.market_value);
                        const plPercent = parseFloat(position.unrealized_plpc) * 100;
                        const plClass = plPercent >= 0 ? 'positive' : 'negative';
                        
                        html += `
                            <div class="portfolio-item">
                                <div>
                                    <strong>${position.symbol}</strong><br>
                                    <small>${parseFloat(position.qty)} shares @ $${parseFloat(position.avg_entry_price).toFixed(2)}</small>
                                </div>
                                <div style="text-align: right;">
                                    <span class="portfolio-value">$${marketValue.toFixed(2)}</span><br>
                                    <small class="${plClass}">${plPercent.toFixed(2)}%</small>
                                </div>
                            </div>
                        `;
                    });
                } else {
                    html += `<p style="text-align: center; margin-top: 15px;">No positions found</p>`;
                }
                
                portfolioContent.innerHTML = html;
            }).catch(err => {
                portfolioContent.innerHTML = `<p class="negative">Error loading portfolio: ${err.message}</p>`;
            });
        }

        // Execute Alpaca order
        function executeAlpacaOrder(symbol, side, amount) {
            if (!alpacaConnected) {
                alert("Please connect to Alpaca first!");
                return;
            }
            
            const order = {
                symbol: symbol,
                qty: Math.floor(amount / 10), // Simple example: assume $10 per share
                side: side,
                type: 'market',
                time_in_force: 'gtc'
            };
            
            alpacaClient.createOrder(order).then(response => {
                alert(`Order executed successfully in ${alpacaMode} mode!\n${side.toUpperCase()} ${order.qty} shares of ${symbol}`);
                loadAlpacaPortfolio();
            }).catch(err => {
                alert(`Error executing order in ${alpacaMode} mode: ${err.message}`);
            });
        }
        
        // Submit an order through Alpaca API - used by AutoTrader
        async function submitAlpacaOrder(orderData) {
            if (!alpacaConnected || !alpacaClient) {
                throw new Error('Alpaca not connected');
            }
            
            try {
                // Add additional order parameters for safety
                const enhancedOrder = {
                    ...orderData,
                    order_class: 'simple'
                };
                
                // Submit the order to Alpaca
                const response = await alpacaClient.createOrder(enhancedOrder);
                return response;
            } catch (error) {
                console.error('Error submitting Alpaca order:', error);
                showNotification('Order submission failed', 'error');
                throw error;
            }
        }

        // Generate AI trading signals with confidence scores
        function generateAISignals() {
          const container = document.getElementById('signals-container');
          container.innerHTML = '';
          const stocks = currentStrategy === 'swing' ? swingStocks : scalpStocks;
          const settings = indicatorSettings[currentStrategy];
          
          // Update strategy info display
          updateStrategyInfo();
          
          // Generate exactly 6 signals
          const signalCount = 6;
          let generatedSignals = 0;
          const signals = []; // Store signals for auto-trading use
          
          while (generatedSignals < signalCount && generatedSignals < stocks.length) {
            const symbol = stocks[generatedSignals];
            const rsi = Math.floor(Math.random() * 40) + (currentStrategy === 'swing' ? 20 : 10);
            const macdBullish = Math.random() > 0.7;
            const nearSupport = Math.random() > 0.6;
            const volumeSpike = Math.random() > 0.8;
            const isBuySignal = Math.random() > 0.3;
            
            // Calculate confidence score based on multiple factors
            let confidenceScore = 0;
            
            // RSI component (30% weight)
            const rsiScore = (50 - rsi) / 50; // Lower RSI = higher score
            confidenceScore += rsiScore * 0.3;
            
            // Volume component (25% weight)
            const volumeScore = volumeSpike ? 0.9 : 0.3;
            confidenceScore += volumeScore * 0.25;
            
            // Trend component (20% weight)
            const trendScore = macdBullish ? 0.8 : 0.4;
            confidenceScore += trendScore * 0.2;
            
            // Support/Resistance component (15% weight)
            const supportScore = nearSupport ? 0.9 : 0.5;
            confidenceScore += supportScore * 0.15;
            
            // Volatility component (10% weight)
            const volatilityScore = Math.random() * 0.5 + 0.5;
            confidenceScore += volatilityScore * 0.1;
            
            // Limit to 0-1 range and round to 2 decimal places
            confidenceScore = Math.min(1, Math.max(0, confidenceScore));
            confidenceScore = Math.round(confidenceScore * 100) / 100;
            
            if ((currentStrategy === 'swing' && rsi < settings.rsiThreshold && (macdBullish || nearSupport)) ||
                (currentStrategy === 'scalp' && rsi < settings.rsiThreshold && volumeSpike)) {
              
              const currentPrice = getCurrentPrice(symbol) || (Math.random() * 100 + 10);
              const priceChange = currentStrategy === 'swing' 
                ? (Math.random() * 8 + 2) 
                : (Math.random() * 2 + 0.5);
              
              const targetPrice = isBuySignal 
                ? (currentPrice * (1 + priceChange/100)).toFixed(2)
                : (currentPrice * (1 - priceChange/100)).toFixed(2);
              
              // Calculate stop price based on ATR (simulated)
              const atr = currentPrice * (currentStrategy === 'swing' ? 0.02 : 0.005);
              const stopPrice = isBuySignal
                ? (currentPrice - (atr * 1.5)).toFixed(2)
                : (currentPrice + (atr * 1.5)).toFixed(2);
              
              // NEW: Dollar-based profit calculation
              const positionSize = currentStrategy === 'swing' ? 1000 : 500;
              const potentialProfit = ((targetPrice - currentPrice) * (positionSize / currentPrice)).toFixed(2);
              
              // Store the signal for auto-trading use
              signals.push({
                symbol,
                action: isBuySignal ? 'BUY' : 'SELL',
                price: currentPrice,
                targetPrice: parseFloat(targetPrice),
                stopPrice: parseFloat(stopPrice),
                confidenceScore,
                strategy: currentStrategy
              });
              
              const signalCard = document.createElement('div');
              signalCard.className = `signal-card ${isBuySignal ? '' : 'sell'}`;
              
              // Determine confidence class
              const confidenceClass = confidenceScore >= 0.85 ? 'high-confidence' :
                                     confidenceScore >= 0.75 ? 'medium-confidence' : 'low-confidence';
              
              signalCard.innerHTML = `
                <div class="signal-title">
                  <span>${symbol}</span>
                  <span>${isBuySignal ? 'BUY' : 'SELL'}</span>
                </div>
                <div class="signal-price">$${currentPrice.toFixed(2)}</div>
                <div class="signal-meta">
                  <div>
                    <span class="confidence-indicator ${confidenceClass}"></span>
                    Confidence: ${(confidenceScore * 100).toFixed(0)}%
                  </div>
                  <div>RSI: ${rsi} | ${currentStrategy}</div>
                  <div>Target: $${targetPrice} | Stop: $${stopPrice}</div>
                </div>
                <div class="signal-profit ${isBuySignal ? 'profit-positive' : 'profit-negative'}">
                  Potential: $${potentialProfit}
                </div>
                <div class="signal-actions">
                  <button data-symbol="${symbol}" data-price="${currentPrice.toFixed(2)}" 
                          class="quick-action-btn ${isBuySignal ? 'buy-btn' : 'sell-btn'}">
                    ${isBuySignal ? 'Buy' : 'Sell'}
                  </button>
                  <button data-symbol="${symbol}" class="quick-action-btn">Chart</button>
                </div>
              `;
              
              container.appendChild(signalCard);
              generatedSignals++;
            }
          }
          
          // Add event listeners
          container.querySelectorAll('.quick-action-btn').forEach(btn => {
            if (btn.classList.contains('buy-btn')) {
              btn.addEventListener('click', (e) => {
                quickBuy(e.target.dataset.symbol, e.target.dataset.price);
              });
            } else if (btn.classList.contains('sell-btn')) {
              btn.addEventListener('click', (e) => {
                quickSell(e.target.dataset.symbol, e.target.dataset.price);
              });
            } else {
              btn.addEventListener('click', (e) => {
                loadTradingViewChart(e.target.dataset.symbol);
              });
            }
          });
          
          // Return signals for auto-trading use
          return signals;
        }

        // Update strategy info display
        function updateStrategyInfo() {
            if (currentStrategy === 'swing') {
                currentStrategyDisplay.textContent = 'Swing Trading (Hold 1–5 Days)';
                currentTimeframe.textContent = '30-min / 1H / Daily charts';
                currentTarget.textContent = '5–10% gains';
                currentStop.textContent = '2–3%';
                currentIndicators.innerHTML = `
                    <li>MACD crossover</li>
                    <li>RSI < 40 = buy zone</li>
                    <li>Support/Resistance trendlines</li>
                `;
                currentCandidates.textContent = swingStocks.join(', ');
                currentLookfor.textContent = 'Oversold small-cap tech stocks';
            } else {
                currentStrategyDisplay.textContent = 'Scalping (Intraday)';
                currentTimeframe.textContent = '1-min / 5-min charts';
                currentTarget.textContent = '1–2% gains';
                currentStop.textContent = '0.5%';
                currentIndicators.innerHTML = `
                    <li>Fast MACD crossover</li>
                    <li>RSI < 30 = buy zone</li>
                    <li>Volume spikes</li>
                `;
                currentCandidates.textContent = scalpStocks.join(', ');
                currentLookfor.textContent = 'High-volume large-cap stocks';
            }
        }

        // Strategy switcher functionality
        function setupStrategySwitcher() {
            const strategySelector = document.getElementById('strategy-selector');
            
            // Set initial strategy
            strategySelector.value = currentStrategy;
            
            // Strategy change handler
            strategySelector.addEventListener('change', (e) => {
                currentStrategy = e.target.value;
                generateAISignals();
            });
        }

        // Update market status and timer
        function updateMarketStatus() {
            const now = moment().tz('America/New_York');
            const dayOfWeek = now.day();
            const isWeekday = dayOfWeek >= 1 && dayOfWeek <= 5;
            
            let status, nextEvent, timeRemaining, hoursInfo;
            
            if (!isWeekday) {
                status = "closed";
                const nextMonday = moment().tz('America/New_York').startOf('week').add(1, 'days').set(marketHours.pre.open);
                timeRemaining = moment.duration(nextMonday.diff(now));
                hoursInfo = "Market closed for the weekend";
            } else {
                const regularOpen = moment().tz('America/New_York').set(marketHours.regular.open);
                const regularClose = moment().tz('America/New_York').set(marketHours.regular.close);
                const preOpen = moment().tz('America/New_York').set(marketHours.pre.open);
                const postClose = moment().tz('America/New_York').set(marketHours.post.close);
                
                if (now.isBefore(preOpen)) {
                    status = "closed";
                    nextEvent = preOpen;
                    timeRemaining = moment.duration(nextEvent.diff(now));
                    hoursInfo = "Pre-market opens at 4:00 AM ET";
                } else if (now.isBefore(regularOpen)) {
                    status = "prepost";
                    nextEvent = regularOpen;
                    timeRemaining = moment.duration(nextEvent.diff(now));
                    hoursInfo = "Regular market opens at 9:30 AM ET";
                } else if (now.isBefore(regularClose)) {
                    status = "open";
                    nextEvent = regularClose;
                    timeRemaining = moment.duration(nextEvent.diff(now));
                    hoursInfo = "Regular market closes at 4:00 PM ET";
                } else if (now.isBefore(postClose)) {
                    status = "prepost";
                    nextEvent = postClose;
                    timeRemaining = moment.duration(nextEvent.diff(now));
                    hoursInfo = "After-hours closes at 8:00 PM ET";
                } else {
                    status = "closed";
                    const tomorrowPre = moment().tz('America/New_York').add(1, 'days').set(marketHours.pre.open);
                    timeRemaining = moment.duration(tomorrowPre.diff(now));
                    hoursInfo = "Market closed for the day";
                }
            }
            
            // Update UI
            marketStatusIndicator.className = `market-status-indicator market-${status}`;
            marketStatusText.textContent = 
                status === "open" ? "Market Open" :
                status === "prepost" ? "Pre/Post Market" : "Market Closed";
            marketHoursInfo.textContent = hoursInfo;
            
            // Format timer
            if (timeRemaining) {
                let timerText = "";
                if (timeRemaining.days() > 0) timerText += `${timeRemaining.days()}d `;
                if (timeRemaining.hours() > 0) timerText += `${timeRemaining.hours()}h `;
                if (timeRemaining.minutes() > 0) timerText += `${timeRemaining.minutes()}m `;
                timerText += `${timeRemaining.seconds()}s`;
                
                marketTimer.textContent = 
                    status === "open" ? `Closes in: ${timerText}` :
                    status === "prepost" ? `Next change in: ${timerText}` : `Opens in: ${timerText}`;
            }
        }

        // Start market status updates
        function startMarketStatusUpdates() {
            if (marketStatusInterval) clearInterval(marketStatusInterval);
            updateMarketStatus();
            marketStatusInterval = setInterval(updateMarketStatus, 1000);
        }

        // Start price updates for active trades
        function startPriceUpdates() {
            if (priceUpdateInterval) clearInterval(priceUpdateInterval);
            
            priceUpdateInterval = setInterval(() => {
                const activeTrades = trades.filter(trade => !trade.exitPrice);
                if (activeTrades.length > 0) {
                    activeTrades.forEach(trade => {
                        const changePercent = (Math.random() * 2 - 1) * 0.5;
                        const newPrice = trade.currentPrice * (1 + changePercent / 100);
                        updateTradePrice(trade.id, newPrice);
                    });
                }
                
                generateAISignals();
            }, 5000);
        }

        // Update stats
        function updateStats() {
            const closedTrades = trades.filter(trade => trade.exitPrice);
            const winningTrades = closedTrades.filter(trade => {
                return calculatePLPercent(trade.entryPrice, trade.exitPrice, trade.direction) >= 0;
            });
            
            totalTradesEl.textContent = closedTrades.length;
            
            if (closedTrades.length > 0) {
                // Win rate
                const winRate = (winningTrades.length / closedTrades.length * 100).toFixed(1);
                winRateEl.textContent = `${winRate}%`;
                
                // Calculate average gain
                const gains = winningTrades.map(trade => 
                    calculatePLPercent(trade.entryPrice, trade.exitPrice, trade.direction)
                );
                const avgGain = gains.length > 0 ? 
                    (gains.reduce((a, b) => a + b, 0) / gains.length).toFixed(1) : 0;
                avgGainEl.textContent = `${avgGain}%`;
                
                // Calculate average loss
                const losingTrades = closedTrades.filter(trade => 
                    calculatePLPercent(trade.entryPrice, trade.exitPrice, trade.direction) < 0
                );
                const losses = losingTrades.map(trade => 
                    calculatePLPercent(trade.entryPrice, trade.exitPrice, trade.direction)
                );
                const avgLoss = losses.length > 0 ? 
                    (losses.reduce((a, b) => a + b, 0) / losses.length).toFixed(1) : 0;
                avgLossEl.textContent = `${avgLoss}%`;
                
                // Risk/Reward Ratio
                const avgWin = gains.length > 0 ? 
                    (gains.reduce((a, b) => a + Math.abs(b), 0) / gains.length) : 0;
                const avgLossValue = losses.length > 0 ? 
                    (losses.reduce((a, b) => a + Math.abs(b), 0) / losses.length) : 0;
                const riskReward = avgLossValue > 0 ? (avgWin / avgLossValue).toFixed(2) : 0;
                riskRewardEl.textContent = riskReward;
                
                // Profit Factor
                const totalProfit = winningTrades.reduce((sum, trade) => {
                    return sum + calculatePLDollar(trade.entryPrice, trade.exitPrice, trade.positionSize, trade.direction);
                }, 0);
                const totalLoss = losingTrades.reduce((sum, trade) => {
                    return sum + Math.abs(calculatePLDollar(trade.entryPrice, trade.exitPrice, trade.positionSize, trade.direction));
                }, 0);
                const profitFactor = totalLoss > 0 ? (totalProfit / totalLoss).toFixed(2) : 0;
                profitFactorEl.textContent = profitFactor;
            } else {
                winRateEl.textContent = '0%';
                avgGainEl.textContent = '0%';
                avgLossEl.textContent = '0%';
                riskRewardEl.textContent = '0.00';
                profitFactorEl.textContent = '0.00';
            }
        }

        // Calculate P/L percentage
        function calculatePLPercent(entry, current, direction) {
            return direction === 'Long' 
                ? (((current - entry) / entry) * 100)
                : (((entry - current) / entry) * 100);
        }

        // Calculate P/L in dollars
        function calculatePLDollar(entry, current, size, direction) {
            return direction === 'Long'
                ? ((current - entry) / entry) * size
                : ((entry - current) / entry) * size;
        }

        // Get P/L class for styling
        function getPLClass(percent) {
            return percent > 0 ? 'positive' : percent < 0 ? 'negative' : 'neutral';
        }

        // Get current price (simulated)
        function getCurrentPrice(symbol) {
            const basePrices = {
                'NIO': 8.50, 'PLTR': 20.10, 'RIVN': 12.75, 
                'FUBO': 1.80, 'MARA': 18.40, 'TSLA': 180.50,
                'AAPL': 170.25, 'NVDA': 450.75, 'SPY': 420.30,
                'QQQ': 350.60, 'META': 310.40, 'AMZN': 135.80,
                'GOOGL': 140.25, 'MSFT': 300.50, 'AMD': 125.30,
                'SOFI': 7.20, 'HOOD': 10.75, 'LCID': 5.60,
                'COIN': 120.40
            };
            return basePrices[symbol] || (Math.random() * 100 + 10).toFixed(2);
        }

        // Save trades to localStorage
        function saveTrades() {
            localStorage.setItem('trades', JSON.stringify(trades));
        }

        // Save watchlist to localStorage
        function saveWatchlist() {
            localStorage.setItem('watchlist', JSON.stringify(watchlist));
        }

        // Generate a unique ID
        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }

        // Export to CSV
        function exportToCSV() {
            const headers = "Symbol,Direction,Entry Price,Exit Price,Position Size,P/L %,P/L $,Stop Loss,Take Profit,Notes,Entry Date,Exit Date\n";
            const csvRows = trades.map(trade => {
                const plPercent = trade.exitPrice ? 
                    calculatePLPercent(trade.entryPrice, trade.exitPrice, trade.direction) : 
                    calculatePLPercent(trade.entryPrice, trade.currentPrice, trade.direction);
                const plDollar = trade.exitPrice ? 
                    calculatePLDollar(trade.entryPrice, trade.exitPrice, trade.positionSize, trade.direction) : 
                    calculatePLDollar(trade.entryPrice, trade.currentPrice, trade.positionSize, trade.direction);
                
                return `"${trade.symbol}",${trade.direction},${trade.entryPrice},${trade.exitPrice || trade.currentPrice},${trade.positionSize},${plPercent.toFixed(2)},${plDollar.toFixed(2)},${trade.stopLoss || ''},${trade.takeProfit || ''},"${trade.notes || ''}","${trade.entryDate}","${trade.exitDate || ''}"`;
            }).join("\n");
            
            const csv = headers + csvRows;
            const blob = new Blob([csv], { type: "text/csv" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "trading-journal.csv";
            a.click();
        }

        // Import from CSV
        function importFromCSV(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const csv = e.target.result;
                const rows = csv.split("\n").slice(1);
                const newTrades = [];
                
                rows.forEach(row => {
                    if (!row.trim()) return;
                    const cols = row.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
                    
                    try {
                        const symbol = cols[0].replace(/"/g, "");
                        const direction = cols[1];
                        const entryPrice = parseFloat(cols[2]);
                        const exitPrice = cols[3] ? parseFloat(cols[3]) : null;
                        const positionSize = parseFloat(cols[4]);
                        const stopLoss = cols[7] ? parseFloat(cols[7]) : null;
                        const takeProfit = cols[8] ? parseFloat(cols[8]) : null;
                        const notes = cols[9] ? cols[9].replace(/"/g, "") : "";
                        const entryDate = cols[10] ? cols[10].replace(/"/g, "") : new Date().toISOString();
                        const exitDate = cols[11] ? cols[11].replace(/"/g, "") : null;
                        
                        newTrades.push({
                            id: generateId(),
                            symbol,
                            direction,
                            entryPrice,
                            currentPrice: exitPrice || entryPrice,
                            exitPrice,
                            positionSize,
                            stopLoss,
                            takeProfit,
                            notes,
                            entryDate,
                            exitDate,
                            chartLink: null
                        });
                    } catch (e) {
                        console.error("Error parsing row:", row, e);
                    }
                });
                
                if (confirm(`Import ${newTrades.length} trades? This will replace your current trades.`)) {
                    trades = newTrades;
                    saveTrades();
                    initDashboard();
                }
            };
            reader.readAsText(file);
        }

        // Render equity curve
        function renderEquityCurve() {
            const equityChartEl = document.getElementById('equity-chart');
            equityChartEl.innerHTML = '<canvas id="equity-chart-canvas"></canvas>';
            
            const ctx = document.getElementById('equity-chart-canvas').getContext('2d');
            
            // Prepare data for the chart
            const closedTrades = trades.filter(trade => trade.exitPrice);
            if (closedTrades.length === 0) {
                equityChartEl.innerHTML = '<p style="text-align: center;">No trade history to display equity curve</p>';
                return;
            }
            
            // Sort trades by exit date
            closedTrades.sort((a, b) => new Date(a.exitDate) - new Date(b.exitDate));
            
            // Calculate cumulative P/L
            let cumulativePL = 0;
            const labels = [];
            const data = [];
            
            closedTrades.forEach(trade => {
                const plDollar = calculatePLDollar(trade.entryPrice, trade.exitPrice, trade.positionSize, trade.direction);
                cumulativePL += plDollar;
                labels.push(new Date(trade.exitDate).toLocaleDateString());
                data.push(cumulativePL);
            });
            
            // Destroy previous chart if it exists
            if (equityChart) {
                equityChart.destroy();
            }
            
            // Create new chart
            equityChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Equity Curve ($)',
                        data: data,
                        borderColor: 'rgba(52, 152, 219, 1)',
                        backgroundColor: 'rgba(52, 152, 219, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: false
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `$${context.raw.toFixed(2)}`;
                                }
                            }
                        }
                    }
                }
                });
        }
        
        // Track active auto-trades and paused state
        let activeAutoTrades = 0;
        let autoTradingPaused = false;

        // Update auto-trading status UI
        function updateAutoTradingUI() {
            const statusIndicator = document.getElementById('auto-status-indicator');
            const statusText = document.getElementById('auto-trading-status-text');
            const radar = document.getElementById('radar-visualization');
            const pauseBtn = document.getElementById('pause-auto-trading');
            const trailPercentSlider = document.getElementById('trail-percent');
            const trailPercentValue = document.getElementById('trail-percent-value');
            
            // First check if Alpaca is connected
            if (!alpacaConnected) {
                statusIndicator.className = 'status-indicator status-disabled';
                statusText.textContent = 'Alpaca Not Connected';
                radar.style.display = 'none';
                pauseBtn.disabled = false;
                pauseBtn.textContent = 'Connect Alpaca First';
                
                // Make the button show the Alpaca connection modal
                pauseBtn.onclick = function() {
                    if (typeof showAlpacaModal === 'function') {
                        showAlpacaModal();
                    } else {
                        alert('Please use the "Connect Alpaca" button at the top of the page.');
                    }
                };
                return;
            } else {
                // Re-enable the pause button
                pauseBtn.disabled = false;
            }
            
            // Then check the auto-trader status
            if (autoTrader.enabled && !autoTradingPaused) {
                statusIndicator.className = 'status-indicator status-active';
                statusText.textContent = 'Active';
                radar.style.display = 'block';
                pauseBtn.textContent = 'Pause Auto-Trading';
            } else if (autoTrader.enabled && autoTradingPaused) {
                statusIndicator.className = 'status-indicator status-paused';
                statusText.textContent = 'Paused';
                radar.style.display = 'none';
                pauseBtn.textContent = 'Resume Auto-Trading';
            } else {
                statusIndicator.className = 'status-indicator status-disabled';
                statusText.textContent = 'Disabled';
                radar.style.display = 'none';
                pauseBtn.textContent = 'Pause Auto-Trading';
            }
            
            // Update trailing stop slider from settings
            if (autoTrader && autoTrader.settings && typeof autoTrader.settings.trailPercent === 'number') {
                const percent = Math.round(autoTrader.settings.trailPercent * 100 * 10) / 10; // Convert to percentage with one decimal
                if (trailPercentSlider) {
                    trailPercentSlider.value = percent;
                    if (trailPercentValue) {
                        trailPercentValue.textContent = percent + '%';
                    }
                }
            }
        }

        // Initialize the range sliders directly
        function initRangeSliders() {
            console.log("Initializing range sliders");
            
            // Get all slider elements
            const maxRiskSlider = document.getElementById('max-risk');
            const maxRiskValue = document.getElementById('max-risk-value');
            const maxTradesSlider = document.getElementById('max-trades');
            const maxTradesValue = document.getElementById('max-trades-value');
            const trailPercentSlider = document.getElementById('trail-percent');
            const trailPercentValue = document.getElementById('trail-percent-value');
            
            if (maxRiskSlider && maxRiskValue) {
                // Set initial value
                maxRiskValue.textContent = maxRiskSlider.value + '%';
                
                // Add event listener
                maxRiskSlider.addEventListener('input', function() {
                    maxRiskValue.textContent = this.value + '%';
                    if (autoTrader && autoTrader.settings) {
                        autoTrader.settings.maxRiskPerTrade = parseFloat(this.value) / 100;
                        autoTrader.saveSettings();
                    }
                });
            } else {
                console.error("Max risk slider elements not found");
            }
            
            if (maxTradesSlider && maxTradesValue) {
                // Set initial value
                maxTradesValue.textContent = maxTradesSlider.value;
                
                // Add event listener
                maxTradesSlider.addEventListener('input', function() {
                    maxTradesValue.textContent = this.value;
                    if (autoTrader && autoTrader.settings) {
                        autoTrader.settings.maxDailyTrades = parseInt(this.value);
                        autoTrader.saveSettings();
                    }
                });
            } else {
                console.error("Max trades slider elements not found");
            }
            
            if (trailPercentSlider && trailPercentValue) {
                // Set initial value
                trailPercentValue.textContent = trailPercentSlider.value + '%';
                
                // Add event listener
                trailPercentSlider.addEventListener('input', function() {
                    trailPercentValue.textContent = this.value + '%';
                    console.log("Trail percent changed to: " + this.value + "%");
                    if (autoTrader && autoTrader.settings) {
                        autoTrader.settings.trailPercent = parseFloat(this.value) / 100;
                        autoTrader.saveSettings();
                    }
                });
            } else {
                console.error("Trail percent slider elements not found");
            }
        }
        
        // Call the initialization function when the DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize slider controls
            setTimeout(initRangeSliders, 1000);
            
            // Initialize UI
            updateAutoTradingUI();
        });

        // Modify the autoTrader.placeTrade function to track active trades
        const originalPlaceTrade = autoTrader.placeTrade;
        autoTrader.placeTrade = async function(signal) {
            if (!this.canPlaceTrade(signal.confidence)) return null;
            
            try {
                activeAutoTrades++;
                document.getElementById('active-auto-trades').textContent = activeAutoTrades;
                
                // Call the original placeTrade function
                const result = await originalPlaceTrade.call(this, signal);
                
                return result;
            } catch (error) {
                console.error('Auto-trade failed:', error);
                return null;
            } finally {
                activeAutoTrades--;
                document.getElementById('active-auto-trades').textContent = activeAutoTrades;
            }
        };
        
        // Try to auto-connect to Alpaca if credentials exist
        function autoConnectAlpaca() {
            // Check if we have saved credentials
            const alpacaMode = localStorage.getItem('alpacaMode');
            if (alpacaMode === 'paper') {
                const key = localStorage.getItem('alpacaPaperKey');
                const secret = localStorage.getItem('alpacaPaperSecret');
                if (key && secret) {
                    console.log('Auto-connecting to Alpaca Paper Trading...');
                    connectAlpaca('paper', key, secret);
                }
            } else if (alpacaMode === 'live') {
                const key = localStorage.getItem('alpacaLiveKey');
                const secret = localStorage.getItem('alpacaLiveSecret');
                if (key && secret) {
                    console.log('Auto-connecting to Alpaca Live Trading...');
                    connectAlpaca('live', key, secret);
                }
            }
        }
        
        // Initialize the dashboard
        initDashboard();
        
        // Try to auto-connect to Alpaca after a short delay to ensure UI is ready
        setTimeout(autoConnectAlpaca, 500);
        
        // Enhanced Telegram Service is now loaded from telegram-enhanced.js
    </script>
    
    <!-- External script files with Telegram integration -->
    <!-- Profit Taking and Safety Features -->
    <script src="profitTaking.js"></script>
    
    <!-- Direct implementation of partial profits and market safety (Step 7) -->
    <script src="partialProfits.js"></script>
    <script src="marketSafety.js"></script>
    
    <!-- Google Sheets Trade Journal & Performance Dashboard (Step 8) -->
    <!-- Using Google Sheets API via browser -->
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="tradeLogger.js"></script>
    <script src="performanceStats.js"></script>
    
    <!-- Telegram Integration - Load in proper dependency order -->
    <!-- Enhanced Telegram Implementation (with centralized configuration) -->
    <script src="telegram-enhanced.js"></script>
    
    <!-- Telegram debugging tools -->
    <script src="telegram-debug.js"></script>
    
    <!-- Telegram test utility -->
    <script src="telegram-test.js"></script>
    
    <!-- Telegram bot command interface -->
    <script src="telegramBot.js"></script>
    
    <!-- AI Trade Analysis & Strategy Optimization (Step 9) -->
    <link rel="stylesheet" href="ai_analysis.css">
    <script src="autoTrader.js"></script>
    <script src="ai_analysis.js"></script>
    
    <!-- Paper Trading Simulation Mode (Step 10) -->
    <link rel="stylesheet" href="simulation-mode.css">
    <script src="simulationEngine.js"></script>
    <script src="simulation-mode.js"></script>
    
    <!-- Multi-Strategy Comparison & Live Optimization (Step 11) -->
    <link rel="stylesheet" href="strategy-comparison.css">
    <script src="strategy-comparison.js"></script>
    <script src="strategy-optimization.js"></script>
    
    <!-- Predictive Strategy Selection with Machine Learning (Step 12) -->
    <link rel="stylesheet" href="ml_prediction.css">
    <script src="ml_prediction.js"></script>
    
    <!-- Reinforcement Learning for Dynamic Parameter Tuning (Step 13) -->
    <link rel="stylesheet" href="rl_tuning.css">
    <script src="rl_tuning.js"></script>
    
    <!-- Genetic Algorithm for Strategy Evolution (Step 14) -->
    <link rel="stylesheet" href="strategy-evolution.css">
    <script src="strategy_evolver.js"></script>
    
    <!-- Service Manager for Backend Services (Step 15) -->
    <link rel="stylesheet" href="service-manager.css">
    <script src="service-manager.js"></script>
    
    <!-- Main automation script - load last to ensure dependencies are available -->
    <!-- Quantum Optimization Integration -->
    <link href="quantum-dashboard.css" rel="stylesheet">
    <script src="quantum_optimizer.js"></script>
    <script src="quantum-dashboard.js"></script>
    
    <!-- Compact Monochrome Layout -->
    <link href="compact-layout.css" rel="stylesheet">
    <script src="compact-layout.js"></script>
    
    <script src="script.js"></script>
    
    <!-- Alpaca modal fix - addresses issue with missing modal -->
    <link rel="stylesheet" href="alpaca-modal-fix.css">
    <script src="alpaca-modal-fix.js"></script>
    
    <!-- Toast container for notifications -->
    <div class="toast-container"></div>
    
    <!-- Dynamically created Alpaca modal will be inserted here by alpaca-modal-fix.js -->
    
    <!-- Help tooltips -->
    <script src="tooltips.js"></script>
</body>
</html>
